{"ast":null,"code":"import { encode } from 'sourcemap-codec';\n\nvar BitSet = function BitSet(arg) {\n  this.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n};\n\nBitSet.prototype.add = function add(n) {\n  this.bits[n >> 5] |= 1 << (n & 31);\n};\n\nBitSet.prototype.has = function has(n) {\n  return !!(this.bits[n >> 5] & 1 << (n & 31));\n};\n\nvar Chunk = function Chunk(start, end, content) {\n  this.start = start;\n  this.end = end;\n  this.original = content;\n  this.intro = '';\n  this.outro = '';\n  this.content = content;\n  this.storeName = false;\n  this.edited = false; // we make these non-enumerable, for sanity while debugging\n\n  Object.defineProperties(this, {\n    previous: {\n      writable: true,\n      value: null\n    },\n    next: {\n      writable: true,\n      value: null\n    }\n  });\n};\n\nChunk.prototype.appendLeft = function appendLeft(content) {\n  this.outro += content;\n};\n\nChunk.prototype.appendRight = function appendRight(content) {\n  this.intro = this.intro + content;\n};\n\nChunk.prototype.clone = function clone() {\n  var chunk = new Chunk(this.start, this.end, this.original);\n  chunk.intro = this.intro;\n  chunk.outro = this.outro;\n  chunk.content = this.content;\n  chunk.storeName = this.storeName;\n  chunk.edited = this.edited;\n  return chunk;\n};\n\nChunk.prototype.contains = function contains(index) {\n  return this.start < index && index < this.end;\n};\n\nChunk.prototype.eachNext = function eachNext(fn) {\n  var chunk = this;\n\n  while (chunk) {\n    fn(chunk);\n    chunk = chunk.next;\n  }\n};\n\nChunk.prototype.eachPrevious = function eachPrevious(fn) {\n  var chunk = this;\n\n  while (chunk) {\n    fn(chunk);\n    chunk = chunk.previous;\n  }\n};\n\nChunk.prototype.edit = function edit(content, storeName, contentOnly) {\n  this.content = content;\n\n  if (!contentOnly) {\n    this.intro = '';\n    this.outro = '';\n  }\n\n  this.storeName = storeName;\n  this.edited = true;\n  return this;\n};\n\nChunk.prototype.prependLeft = function prependLeft(content) {\n  this.outro = content + this.outro;\n};\n\nChunk.prototype.prependRight = function prependRight(content) {\n  this.intro = content + this.intro;\n};\n\nChunk.prototype.split = function split(index) {\n  var sliceIndex = index - this.start;\n  var originalBefore = this.original.slice(0, sliceIndex);\n  var originalAfter = this.original.slice(sliceIndex);\n  this.original = originalBefore;\n  var newChunk = new Chunk(index, this.end, originalAfter);\n  newChunk.outro = this.outro;\n  this.outro = '';\n  this.end = index;\n\n  if (this.edited) {\n    // TODO is this block necessary?...\n    newChunk.edit('', false);\n    this.content = '';\n  } else {\n    this.content = originalBefore;\n  }\n\n  newChunk.next = this.next;\n\n  if (newChunk.next) {\n    newChunk.next.previous = newChunk;\n  }\n\n  newChunk.previous = this;\n  this.next = newChunk;\n  return newChunk;\n};\n\nChunk.prototype.toString = function toString() {\n  return this.intro + this.content + this.outro;\n};\n\nChunk.prototype.trimEnd = function trimEnd(rx) {\n  this.outro = this.outro.replace(rx, '');\n\n  if (this.outro.length) {\n    return true;\n  }\n\n  var trimmed = this.content.replace(rx, '');\n\n  if (trimmed.length) {\n    if (trimmed !== this.content) {\n      this.split(this.start + trimmed.length).edit('', undefined, true);\n    }\n\n    return true;\n  } else {\n    this.edit('', undefined, true);\n    this.intro = this.intro.replace(rx, '');\n\n    if (this.intro.length) {\n      return true;\n    }\n  }\n};\n\nChunk.prototype.trimStart = function trimStart(rx) {\n  this.intro = this.intro.replace(rx, '');\n\n  if (this.intro.length) {\n    return true;\n  }\n\n  var trimmed = this.content.replace(rx, '');\n\n  if (trimmed.length) {\n    if (trimmed !== this.content) {\n      this.split(this.end - trimmed.length);\n      this.edit('', undefined, true);\n    }\n\n    return true;\n  } else {\n    this.edit('', undefined, true);\n    this.outro = this.outro.replace(rx, '');\n\n    if (this.outro.length) {\n      return true;\n    }\n  }\n};\n\nvar btoa = function () {\n  throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\n\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n  btoa = function (str) {\n    return window.btoa(unescape(encodeURIComponent(str)));\n  };\n} else if (typeof Buffer === 'function') {\n  btoa = function (str) {\n    return Buffer.from(str, 'utf-8').toString('base64');\n  };\n}\n\nvar SourceMap = function SourceMap(properties) {\n  this.version = 3;\n  this.file = properties.file;\n  this.sources = properties.sources;\n  this.sourcesContent = properties.sourcesContent;\n  this.names = properties.names;\n  this.mappings = encode(properties.mappings);\n};\n\nSourceMap.prototype.toString = function toString() {\n  return JSON.stringify(this);\n};\n\nSourceMap.prototype.toUrl = function toUrl() {\n  return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n};\n\nfunction guessIndent(code) {\n  var lines = code.split('\\n');\n  var tabbed = lines.filter(function (line) {\n    return /^\\t+/.test(line);\n  });\n  var spaced = lines.filter(function (line) {\n    return /^ {2,}/.test(line);\n  });\n\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  } // More lines tabbed than spaced? Assume tabs, and\n  // default to tabs in the case of a tie (or nothing\n  // to go on)\n\n\n  if (tabbed.length >= spaced.length) {\n    return '\\t';\n  } // Otherwise, we need to guess the multiple\n\n\n  var min = spaced.reduce(function (previous, current) {\n    var numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n  var fromParts = from.split(/[/\\\\]/);\n  var toParts = to.split(/[/\\\\]/);\n  fromParts.pop(); // get dirname\n\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n\n  if (fromParts.length) {\n    var i = fromParts.length;\n\n    while (i--) {\n      fromParts[i] = '..';\n    }\n  }\n\n  return fromParts.concat(toParts).join('/');\n}\n\nvar toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n  return toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n  var originalLines = source.split('\\n');\n  var lineOffsets = [];\n\n  for (var i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n\n  return function locate(index) {\n    var i = 0;\n    var j = lineOffsets.length;\n\n    while (i < j) {\n      var m = i + j >> 1;\n\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n\n    var line = i - 1;\n    var column = index - lineOffsets[line];\n    return {\n      line: line,\n      column: column\n    };\n  };\n}\n\nvar Mappings = function Mappings(hires) {\n  this.hires = hires;\n  this.generatedCodeLine = 0;\n  this.generatedCodeColumn = 0;\n  this.raw = [];\n  this.rawSegments = this.raw[this.generatedCodeLine] = [];\n  this.pending = null;\n};\n\nMappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {\n  if (content.length) {\n    var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n    if (nameIndex >= 0) {\n      segment.push(nameIndex);\n    }\n\n    this.rawSegments.push(segment);\n  } else if (this.pending) {\n    this.rawSegments.push(this.pending);\n  }\n\n  this.advance(content);\n  this.pending = null;\n};\n\nMappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n  var originalCharIndex = chunk.start;\n  var first = true;\n\n  while (originalCharIndex < chunk.end) {\n    if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n      this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n    }\n\n    if (original[originalCharIndex] === '\\n') {\n      loc.line += 1;\n      loc.column = 0;\n      this.generatedCodeLine += 1;\n      this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      this.generatedCodeColumn = 0;\n      first = true;\n    } else {\n      loc.column += 1;\n      this.generatedCodeColumn += 1;\n      first = false;\n    }\n\n    originalCharIndex += 1;\n  }\n\n  this.pending = null;\n};\n\nMappings.prototype.advance = function advance(str) {\n  if (!str) {\n    return;\n  }\n\n  var lines = str.split('\\n');\n\n  if (lines.length > 1) {\n    for (var i = 0; i < lines.length - 1; i++) {\n      this.generatedCodeLine++;\n      this.raw[this.generatedCodeLine] = this.rawSegments = [];\n    }\n\n    this.generatedCodeColumn = 0;\n  }\n\n  this.generatedCodeColumn += lines[lines.length - 1].length;\n};\n\nvar n = '\\n';\nvar warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\n\nvar MagicString = function MagicString(string, options) {\n  if (options === void 0) options = {};\n  var chunk = new Chunk(0, string.length, string);\n  Object.defineProperties(this, {\n    original: {\n      writable: true,\n      value: string\n    },\n    outro: {\n      writable: true,\n      value: ''\n    },\n    intro: {\n      writable: true,\n      value: ''\n    },\n    firstChunk: {\n      writable: true,\n      value: chunk\n    },\n    lastChunk: {\n      writable: true,\n      value: chunk\n    },\n    lastSearchedChunk: {\n      writable: true,\n      value: chunk\n    },\n    byStart: {\n      writable: true,\n      value: {}\n    },\n    byEnd: {\n      writable: true,\n      value: {}\n    },\n    filename: {\n      writable: true,\n      value: options.filename\n    },\n    indentExclusionRanges: {\n      writable: true,\n      value: options.indentExclusionRanges\n    },\n    sourcemapLocations: {\n      writable: true,\n      value: new BitSet()\n    },\n    storedNames: {\n      writable: true,\n      value: {}\n    },\n    indentStr: {\n      writable: true,\n      value: guessIndent(string)\n    }\n  });\n  this.byStart[0] = chunk;\n  this.byEnd[string.length] = chunk;\n};\n\nMagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {\n  this.sourcemapLocations.add(char);\n};\n\nMagicString.prototype.append = function append(content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('outro content must be a string');\n  }\n\n  this.outro += content;\n  return this;\n};\n\nMagicString.prototype.appendLeft = function appendLeft(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byEnd[index];\n\n  if (chunk) {\n    chunk.appendLeft(content);\n  } else {\n    this.intro += content;\n  }\n\n  return this;\n};\n\nMagicString.prototype.appendRight = function appendRight(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byStart[index];\n\n  if (chunk) {\n    chunk.appendRight(content);\n  } else {\n    this.outro += content;\n  }\n\n  return this;\n};\n\nMagicString.prototype.clone = function clone() {\n  var cloned = new MagicString(this.original, {\n    filename: this.filename\n  });\n  var originalChunk = this.firstChunk;\n  var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n\n  while (originalChunk) {\n    cloned.byStart[clonedChunk.start] = clonedChunk;\n    cloned.byEnd[clonedChunk.end] = clonedChunk;\n    var nextOriginalChunk = originalChunk.next;\n    var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n    if (nextClonedChunk) {\n      clonedChunk.next = nextClonedChunk;\n      nextClonedChunk.previous = clonedChunk;\n      clonedChunk = nextClonedChunk;\n    }\n\n    originalChunk = nextOriginalChunk;\n  }\n\n  cloned.lastChunk = clonedChunk;\n\n  if (this.indentExclusionRanges) {\n    cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n  }\n\n  cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n  cloned.intro = this.intro;\n  cloned.outro = this.outro;\n  return cloned;\n};\n\nMagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {\n  var this$1 = this;\n  options = options || {};\n  var sourceIndex = 0;\n  var names = Object.keys(this.storedNames);\n  var mappings = new Mappings(options.hires);\n  var locate = getLocator(this.original);\n\n  if (this.intro) {\n    mappings.advance(this.intro);\n  }\n\n  this.firstChunk.eachNext(function (chunk) {\n    var loc = locate(chunk.start);\n\n    if (chunk.intro.length) {\n      mappings.advance(chunk.intro);\n    }\n\n    if (chunk.edited) {\n      mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n    } else {\n      mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);\n    }\n\n    if (chunk.outro.length) {\n      mappings.advance(chunk.outro);\n    }\n  });\n  return {\n    file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n    sources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n    sourcesContent: options.includeContent ? [this.original] : [null],\n    names: names,\n    mappings: mappings.raw\n  };\n};\n\nMagicString.prototype.generateMap = function generateMap(options) {\n  return new SourceMap(this.generateDecodedMap(options));\n};\n\nMagicString.prototype.getIndentString = function getIndentString() {\n  return this.indentStr === null ? '\\t' : this.indentStr;\n};\n\nMagicString.prototype.indent = function indent(indentStr, options) {\n  var pattern = /^[^\\r\\n]/gm;\n\n  if (isObject(indentStr)) {\n    options = indentStr;\n    indentStr = undefined;\n  }\n\n  indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n  if (indentStr === '') {\n    return this;\n  } // noop\n\n\n  options = options || {}; // Process exclusion ranges\n\n  var isExcluded = {};\n\n  if (options.exclude) {\n    var exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n    exclusions.forEach(function (exclusion) {\n      for (var i = exclusion[0]; i < exclusion[1]; i += 1) {\n        isExcluded[i] = true;\n      }\n    });\n  }\n\n  var shouldIndentNextCharacter = options.indentStart !== false;\n\n  var replacer = function (match) {\n    if (shouldIndentNextCharacter) {\n      return \"\" + indentStr + match;\n    }\n\n    shouldIndentNextCharacter = true;\n    return match;\n  };\n\n  this.intro = this.intro.replace(pattern, replacer);\n  var charIndex = 0;\n  var chunk = this.firstChunk;\n\n  while (chunk) {\n    var end = chunk.end;\n\n    if (chunk.edited) {\n      if (!isExcluded[charIndex]) {\n        chunk.content = chunk.content.replace(pattern, replacer);\n\n        if (chunk.content.length) {\n          shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n        }\n      }\n    } else {\n      charIndex = chunk.start;\n\n      while (charIndex < end) {\n        if (!isExcluded[charIndex]) {\n          var char = this.original[charIndex];\n\n          if (char === '\\n') {\n            shouldIndentNextCharacter = true;\n          } else if (char !== '\\r' && shouldIndentNextCharacter) {\n            shouldIndentNextCharacter = false;\n\n            if (charIndex === chunk.start) {\n              chunk.prependRight(indentStr);\n            } else {\n              this._splitChunk(chunk, charIndex);\n\n              chunk = chunk.next;\n              chunk.prependRight(indentStr);\n            }\n          }\n        }\n\n        charIndex += 1;\n      }\n    }\n\n    charIndex = chunk.end;\n    chunk = chunk.next;\n  }\n\n  this.outro = this.outro.replace(pattern, replacer);\n  return this;\n};\n\nMagicString.prototype.insert = function insert() {\n  throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n};\n\nMagicString.prototype.insertLeft = function insertLeft(index, content) {\n  if (!warned.insertLeft) {\n    console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\n    warned.insertLeft = true;\n  }\n\n  return this.appendLeft(index, content);\n};\n\nMagicString.prototype.insertRight = function insertRight(index, content) {\n  if (!warned.insertRight) {\n    console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\n    warned.insertRight = true;\n  }\n\n  return this.prependRight(index, content);\n};\n\nMagicString.prototype.move = function move(start, end, index) {\n  if (index >= start && index <= end) {\n    throw new Error('Cannot move a selection inside itself');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  this._split(index);\n\n  var first = this.byStart[start];\n  var last = this.byEnd[end];\n  var oldLeft = first.previous;\n  var oldRight = last.next;\n  var newRight = this.byStart[index];\n\n  if (!newRight && last === this.lastChunk) {\n    return this;\n  }\n\n  var newLeft = newRight ? newRight.previous : this.lastChunk;\n\n  if (oldLeft) {\n    oldLeft.next = oldRight;\n  }\n\n  if (oldRight) {\n    oldRight.previous = oldLeft;\n  }\n\n  if (newLeft) {\n    newLeft.next = first;\n  }\n\n  if (newRight) {\n    newRight.previous = last;\n  }\n\n  if (!first.previous) {\n    this.firstChunk = last.next;\n  }\n\n  if (!last.next) {\n    this.lastChunk = first.previous;\n    this.lastChunk.next = null;\n  }\n\n  first.previous = newLeft;\n  last.next = newRight || null;\n\n  if (!newLeft) {\n    this.firstChunk = first;\n  }\n\n  if (!newRight) {\n    this.lastChunk = last;\n  }\n\n  return this;\n};\n\nMagicString.prototype.overwrite = function overwrite(start, end, content, options) {\n  if (typeof content !== 'string') {\n    throw new TypeError('replacement content must be a string');\n  }\n\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  if (end > this.original.length) {\n    throw new Error('end is out of bounds');\n  }\n\n  if (start === end) {\n    throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  if (options === true) {\n    if (!warned.storeName) {\n      console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\n      warned.storeName = true;\n    }\n\n    options = {\n      storeName: true\n    };\n  }\n\n  var storeName = options !== undefined ? options.storeName : false;\n  var contentOnly = options !== undefined ? options.contentOnly : false;\n\n  if (storeName) {\n    var original = this.original.slice(start, end);\n    this.storedNames[original] = true;\n  }\n\n  var first = this.byStart[start];\n  var last = this.byEnd[end];\n\n  if (first) {\n    if (end > first.end && first.next !== this.byStart[first.end]) {\n      throw new Error('Cannot overwrite across a split point');\n    }\n\n    first.edit(content, storeName, contentOnly);\n\n    if (first !== last) {\n      var chunk = first.next;\n\n      while (chunk !== last) {\n        chunk.edit('', false);\n        chunk = chunk.next;\n      }\n\n      chunk.edit('', false);\n    }\n  } else {\n    // must be inserting at the end\n    var newChunk = new Chunk(start, end, '').edit(content, storeName); // TODO last chunk in the array may not be the last chunk, if it's moved...\n\n    last.next = newChunk;\n    newChunk.previous = last;\n  }\n\n  return this;\n};\n\nMagicString.prototype.prepend = function prepend(content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('outro content must be a string');\n  }\n\n  this.intro = content + this.intro;\n  return this;\n};\n\nMagicString.prototype.prependLeft = function prependLeft(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byEnd[index];\n\n  if (chunk) {\n    chunk.prependLeft(content);\n  } else {\n    this.intro = content + this.intro;\n  }\n\n  return this;\n};\n\nMagicString.prototype.prependRight = function prependRight(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n\n  this._split(index);\n\n  var chunk = this.byStart[index];\n\n  if (chunk) {\n    chunk.prependRight(content);\n  } else {\n    this.outro = content + this.outro;\n  }\n\n  return this;\n};\n\nMagicString.prototype.remove = function remove(start, end) {\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  if (start === end) {\n    return this;\n  }\n\n  if (start < 0 || end > this.original.length) {\n    throw new Error('Character is out of bounds');\n  }\n\n  if (start > end) {\n    throw new Error('end must be greater than start');\n  }\n\n  this._split(start);\n\n  this._split(end);\n\n  var chunk = this.byStart[start];\n\n  while (chunk) {\n    chunk.intro = '';\n    chunk.outro = '';\n    chunk.edit('');\n    chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n  }\n\n  return this;\n};\n\nMagicString.prototype.lastChar = function lastChar() {\n  if (this.outro.length) {\n    return this.outro[this.outro.length - 1];\n  }\n\n  var chunk = this.lastChunk;\n\n  do {\n    if (chunk.outro.length) {\n      return chunk.outro[chunk.outro.length - 1];\n    }\n\n    if (chunk.content.length) {\n      return chunk.content[chunk.content.length - 1];\n    }\n\n    if (chunk.intro.length) {\n      return chunk.intro[chunk.intro.length - 1];\n    }\n  } while (chunk = chunk.previous);\n\n  if (this.intro.length) {\n    return this.intro[this.intro.length - 1];\n  }\n\n  return '';\n};\n\nMagicString.prototype.lastLine = function lastLine() {\n  var lineIndex = this.outro.lastIndexOf(n);\n\n  if (lineIndex !== -1) {\n    return this.outro.substr(lineIndex + 1);\n  }\n\n  var lineStr = this.outro;\n  var chunk = this.lastChunk;\n\n  do {\n    if (chunk.outro.length > 0) {\n      lineIndex = chunk.outro.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.outro.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.outro + lineStr;\n    }\n\n    if (chunk.content.length > 0) {\n      lineIndex = chunk.content.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.content.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.content + lineStr;\n    }\n\n    if (chunk.intro.length > 0) {\n      lineIndex = chunk.intro.lastIndexOf(n);\n\n      if (lineIndex !== -1) {\n        return chunk.intro.substr(lineIndex + 1) + lineStr;\n      }\n\n      lineStr = chunk.intro + lineStr;\n    }\n  } while (chunk = chunk.previous);\n\n  lineIndex = this.intro.lastIndexOf(n);\n\n  if (lineIndex !== -1) {\n    return this.intro.substr(lineIndex + 1) + lineStr;\n  }\n\n  return this.intro + lineStr;\n};\n\nMagicString.prototype.slice = function slice(start, end) {\n  if (start === void 0) start = 0;\n  if (end === void 0) end = this.original.length;\n\n  while (start < 0) {\n    start += this.original.length;\n  }\n\n  while (end < 0) {\n    end += this.original.length;\n  }\n\n  var result = ''; // find start chunk\n\n  var chunk = this.firstChunk;\n\n  while (chunk && (chunk.start > start || chunk.end <= start)) {\n    // found end chunk before start\n    if (chunk.start < end && chunk.end >= end) {\n      return result;\n    }\n\n    chunk = chunk.next;\n  }\n\n  if (chunk && chunk.edited && chunk.start !== start) {\n    throw new Error(\"Cannot use replaced character \" + start + \" as slice start anchor.\");\n  }\n\n  var startChunk = chunk;\n\n  while (chunk) {\n    if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n      result += chunk.intro;\n    }\n\n    var containsEnd = chunk.start < end && chunk.end >= end;\n\n    if (containsEnd && chunk.edited && chunk.end !== end) {\n      throw new Error(\"Cannot use replaced character \" + end + \" as slice end anchor.\");\n    }\n\n    var sliceStart = startChunk === chunk ? start - chunk.start : 0;\n    var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n    result += chunk.content.slice(sliceStart, sliceEnd);\n\n    if (chunk.outro && (!containsEnd || chunk.end === end)) {\n      result += chunk.outro;\n    }\n\n    if (containsEnd) {\n      break;\n    }\n\n    chunk = chunk.next;\n  }\n\n  return result;\n}; // TODO deprecate this? not really very useful\n\n\nMagicString.prototype.snip = function snip(start, end) {\n  var clone = this.clone();\n  clone.remove(0, start);\n  clone.remove(end, clone.original.length);\n  return clone;\n};\n\nMagicString.prototype._split = function _split(index) {\n  if (this.byStart[index] || this.byEnd[index]) {\n    return;\n  }\n\n  var chunk = this.lastSearchedChunk;\n  var searchForward = index > chunk.end;\n\n  while (chunk) {\n    if (chunk.contains(index)) {\n      return this._splitChunk(chunk, index);\n    }\n\n    chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n  }\n};\n\nMagicString.prototype._splitChunk = function _splitChunk(chunk, index) {\n  if (chunk.edited && chunk.content.length) {\n    // zero-length edited chunks are a special case (overlapping replacements)\n    var loc = getLocator(this.original)(index);\n    throw new Error(\"Cannot split a chunk that has already been edited (\" + loc.line + \":\" + loc.column + \" – \\\"\" + chunk.original + \"\\\")\");\n  }\n\n  var newChunk = chunk.split(index);\n  this.byEnd[index] = chunk;\n  this.byStart[index] = newChunk;\n  this.byEnd[newChunk.end] = newChunk;\n\n  if (chunk === this.lastChunk) {\n    this.lastChunk = newChunk;\n  }\n\n  this.lastSearchedChunk = chunk;\n  return true;\n};\n\nMagicString.prototype.toString = function toString() {\n  var str = this.intro;\n  var chunk = this.firstChunk;\n\n  while (chunk) {\n    str += chunk.toString();\n    chunk = chunk.next;\n  }\n\n  return str + this.outro;\n};\n\nMagicString.prototype.isEmpty = function isEmpty() {\n  var chunk = this.firstChunk;\n\n  do {\n    if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {\n      return false;\n    }\n  } while (chunk = chunk.next);\n\n  return true;\n};\n\nMagicString.prototype.length = function length() {\n  var chunk = this.firstChunk;\n  var length = 0;\n\n  do {\n    length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n  } while (chunk = chunk.next);\n\n  return length;\n};\n\nMagicString.prototype.trimLines = function trimLines() {\n  return this.trim('[\\\\r\\\\n]');\n};\n\nMagicString.prototype.trim = function trim(charType) {\n  return this.trimStart(charType).trimEnd(charType);\n};\n\nMagicString.prototype.trimEndAborted = function trimEndAborted(charType) {\n  var rx = new RegExp((charType || '\\\\s') + '+$');\n  this.outro = this.outro.replace(rx, '');\n\n  if (this.outro.length) {\n    return true;\n  }\n\n  var chunk = this.lastChunk;\n\n  do {\n    var end = chunk.end;\n    var aborted = chunk.trimEnd(rx); // if chunk was trimmed, we have a new lastChunk\n\n    if (chunk.end !== end) {\n      if (this.lastChunk === chunk) {\n        this.lastChunk = chunk.next;\n      }\n\n      this.byEnd[chunk.end] = chunk;\n      this.byStart[chunk.next.start] = chunk.next;\n      this.byEnd[chunk.next.end] = chunk.next;\n    }\n\n    if (aborted) {\n      return true;\n    }\n\n    chunk = chunk.previous;\n  } while (chunk);\n\n  return false;\n};\n\nMagicString.prototype.trimEnd = function trimEnd(charType) {\n  this.trimEndAborted(charType);\n  return this;\n};\n\nMagicString.prototype.trimStartAborted = function trimStartAborted(charType) {\n  var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n  this.intro = this.intro.replace(rx, '');\n\n  if (this.intro.length) {\n    return true;\n  }\n\n  var chunk = this.firstChunk;\n\n  do {\n    var end = chunk.end;\n    var aborted = chunk.trimStart(rx);\n\n    if (chunk.end !== end) {\n      // special case...\n      if (chunk === this.lastChunk) {\n        this.lastChunk = chunk.next;\n      }\n\n      this.byEnd[chunk.end] = chunk;\n      this.byStart[chunk.next.start] = chunk.next;\n      this.byEnd[chunk.next.end] = chunk.next;\n    }\n\n    if (aborted) {\n      return true;\n    }\n\n    chunk = chunk.next;\n  } while (chunk);\n\n  return false;\n};\n\nMagicString.prototype.trimStart = function trimStart(charType) {\n  this.trimStartAborted(charType);\n  return this;\n};\n\nvar hasOwnProp = Object.prototype.hasOwnProperty;\n\nvar Bundle = function Bundle(options) {\n  if (options === void 0) options = {};\n  this.intro = options.intro || '';\n  this.separator = options.separator !== undefined ? options.separator : '\\n';\n  this.sources = [];\n  this.uniqueSources = [];\n  this.uniqueSourceIndexByFilename = {};\n};\n\nBundle.prototype.addSource = function addSource(source) {\n  if (source instanceof MagicString) {\n    return this.addSource({\n      content: source,\n      filename: source.filename,\n      separator: this.separator\n    });\n  }\n\n  if (!isObject(source) || !source.content) {\n    throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n  }\n\n  ['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {\n    if (!hasOwnProp.call(source, option)) {\n      source[option] = source.content[option];\n    }\n  });\n\n  if (source.separator === undefined) {\n    // TODO there's a bunch of this sort of thing, needs cleaning up\n    source.separator = this.separator;\n  }\n\n  if (source.filename) {\n    if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n      this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n      this.uniqueSources.push({\n        filename: source.filename,\n        content: source.content.original\n      });\n    } else {\n      var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\n      if (source.content.original !== uniqueSource.content) {\n        throw new Error(\"Illegal source: same filename (\" + source.filename + \"), different contents\");\n      }\n    }\n  }\n\n  this.sources.push(source);\n  return this;\n};\n\nBundle.prototype.append = function append(str, options) {\n  this.addSource({\n    content: new MagicString(str),\n    separator: options && options.separator || ''\n  });\n  return this;\n};\n\nBundle.prototype.clone = function clone() {\n  var bundle = new Bundle({\n    intro: this.intro,\n    separator: this.separator\n  });\n  this.sources.forEach(function (source) {\n    bundle.addSource({\n      filename: source.filename,\n      content: source.content.clone(),\n      separator: source.separator\n    });\n  });\n  return bundle;\n};\n\nBundle.prototype.generateDecodedMap = function generateDecodedMap(options) {\n  var this$1 = this;\n  if (options === void 0) options = {};\n  var names = [];\n  this.sources.forEach(function (source) {\n    Object.keys(source.content.storedNames).forEach(function (name) {\n      if (!~names.indexOf(name)) {\n        names.push(name);\n      }\n    });\n  });\n  var mappings = new Mappings(options.hires);\n\n  if (this.intro) {\n    mappings.advance(this.intro);\n  }\n\n  this.sources.forEach(function (source, i) {\n    if (i > 0) {\n      mappings.advance(this$1.separator);\n    }\n\n    var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[source.filename] : -1;\n    var magicString = source.content;\n    var locate = getLocator(magicString.original);\n\n    if (magicString.intro) {\n      mappings.advance(magicString.intro);\n    }\n\n    magicString.firstChunk.eachNext(function (chunk) {\n      var loc = locate(chunk.start);\n\n      if (chunk.intro.length) {\n        mappings.advance(chunk.intro);\n      }\n\n      if (source.filename) {\n        if (chunk.edited) {\n          mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n        } else {\n          mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);\n        }\n      } else {\n        mappings.advance(chunk.content);\n      }\n\n      if (chunk.outro.length) {\n        mappings.advance(chunk.outro);\n      }\n    });\n\n    if (magicString.outro) {\n      mappings.advance(magicString.outro);\n    }\n  });\n  return {\n    file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n    sources: this.uniqueSources.map(function (source) {\n      return options.file ? getRelativePath(options.file, source.filename) : source.filename;\n    }),\n    sourcesContent: this.uniqueSources.map(function (source) {\n      return options.includeContent ? source.content : null;\n    }),\n    names: names,\n    mappings: mappings.raw\n  };\n};\n\nBundle.prototype.generateMap = function generateMap(options) {\n  return new SourceMap(this.generateDecodedMap(options));\n};\n\nBundle.prototype.getIndentString = function getIndentString() {\n  var indentStringCounts = {};\n  this.sources.forEach(function (source) {\n    var indentStr = source.content.indentStr;\n\n    if (indentStr === null) {\n      return;\n    }\n\n    if (!indentStringCounts[indentStr]) {\n      indentStringCounts[indentStr] = 0;\n    }\n\n    indentStringCounts[indentStr] += 1;\n  });\n  return Object.keys(indentStringCounts).sort(function (a, b) {\n    return indentStringCounts[a] - indentStringCounts[b];\n  })[0] || '\\t';\n};\n\nBundle.prototype.indent = function indent(indentStr) {\n  var this$1 = this;\n\n  if (!arguments.length) {\n    indentStr = this.getIndentString();\n  }\n\n  if (indentStr === '') {\n    return this;\n  } // noop\n\n\n  var trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n  this.sources.forEach(function (source, i) {\n    var separator = source.separator !== undefined ? source.separator : this$1.separator;\n    var indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n    source.content.indent(indentStr, {\n      exclude: source.indentExclusionRanges,\n      indentStart: indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\n    });\n    trailingNewline = source.content.lastChar() === '\\n';\n  });\n\n  if (this.intro) {\n    this.intro = indentStr + this.intro.replace(/^[^\\n]/gm, function (match, index) {\n      return index > 0 ? indentStr + match : match;\n    });\n  }\n\n  return this;\n};\n\nBundle.prototype.prepend = function prepend(str) {\n  this.intro = str + this.intro;\n  return this;\n};\n\nBundle.prototype.toString = function toString() {\n  var this$1 = this;\n  var body = this.sources.map(function (source, i) {\n    var separator = source.separator !== undefined ? source.separator : this$1.separator;\n    var str = (i > 0 ? separator : '') + source.content.toString();\n    return str;\n  }).join('');\n  return this.intro + body;\n};\n\nBundle.prototype.isEmpty = function isEmpty() {\n  if (this.intro.length && this.intro.trim()) {\n    return false;\n  }\n\n  if (this.sources.some(function (source) {\n    return !source.content.isEmpty();\n  })) {\n    return false;\n  }\n\n  return true;\n};\n\nBundle.prototype.length = function length() {\n  return this.sources.reduce(function (length, source) {\n    return length + source.content.length();\n  }, this.intro.length);\n};\n\nBundle.prototype.trimLines = function trimLines() {\n  return this.trim('[\\\\r\\\\n]');\n};\n\nBundle.prototype.trim = function trim(charType) {\n  return this.trimStart(charType).trimEnd(charType);\n};\n\nBundle.prototype.trimStart = function trimStart(charType) {\n  var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n  this.intro = this.intro.replace(rx, '');\n\n  if (!this.intro) {\n    var source;\n    var i = 0;\n\n    do {\n      source = this.sources[i++];\n\n      if (!source) {\n        break;\n      }\n    } while (!source.content.trimStartAborted(charType));\n  }\n\n  return this;\n};\n\nBundle.prototype.trimEnd = function trimEnd(charType) {\n  var rx = new RegExp((charType || '\\\\s') + '+$');\n  var source;\n  var i = this.sources.length - 1;\n\n  do {\n    source = this.sources[i--];\n\n    if (!source) {\n      this.intro = this.intro.replace(rx, '');\n      break;\n    }\n  } while (!source.content.trimEndAborted(charType));\n\n  return this;\n};\n\nexport default MagicString;\nexport { Bundle, SourceMap };","map":{"version":3,"sources":["../src/BitSet.js","../src/Chunk.js","../src/SourceMap.js","../src/utils/guessIndent.js","../src/utils/getRelativePath.js","../src/utils/isObject.js","../src/utils/getLocator.js","../src/utils/Mappings.js","../src/MagicString.js","../src/Bundle.js"],"names":["const","let","this"],"mappings":"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","sourcesContent":["export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}","export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext:     { writable: true, value: null }\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n","import { encode } from 'sourcemap-codec';\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = str => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = str => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n","export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter(line => /^\\t+/.test(line));\n\tconst spaced = lines.filter(line => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n","export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n","const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n","export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n","export default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n","import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal:              { writable: true, value: string },\n\t\t\toutro:                 { writable: true, value: '' },\n\t\t\tintro:                 { writable: true, value: '' },\n\t\t\tfirstChunk:            { writable: true, value: chunk },\n\t\t\tlastChunk:             { writable: true, value: chunk },\n\t\t\tlastSearchedChunk:     { writable: true, value: chunk },\n\t\t\tbyStart:               { writable: true, value: {} },\n\t\t\tbyEnd:                 { writable: true, value: {} },\n\t\t\tfilename:              { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations:    { writable: true, value: new BitSet() },\n\t\t\tstoredNames:           { writable: true, value: {} },\n\t\t\tindentStr:             { writable: true, value: guessIndent(string) }\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext(chunk => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach(exclusion => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = match => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tthis.storedNames[original] = true;\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tif (end > first.end && first.next !== this.byStart[first.end]) {\n\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\n\t\t\tif (first !== last) {\n\t\t\t\tlet chunk = first.next;\n\t\t\t\twhile (chunk !== last) {\n\t\t\t\t\tchunk.edit('', false);\n\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length)\n\t\t\treturn this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length)\n\t\t\t\treturn chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length)\n\t\t\t\treturn chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length)\n\t\t\t\treturn chunk.intro[chunk.intro.length - 1];\n\t\t} while (chunk = chunk.previous);\n\t\tif (this.intro.length)\n\t\t\treturn this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1)\n\t\t\treturn this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while (chunk = chunk.previous);\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1)\n\t\t\treturn this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${\n\t\t\t\t\tchunk.original\n\t\t\t\t}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (chunk.intro.length && chunk.intro.trim() ||\n\t\t\t\t\tchunk.content.length && chunk.content.trim() ||\n\t\t\t\t\tchunk.outro.length && chunk.outro.trim())\n\t\t\t\treturn false;\n\t\t} while (chunk = chunk.next);\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while (chunk = chunk.next);\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach(option => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || ''\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator\n\t\t});\n\n\t\tthis.sources.forEach(source => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach(source => {\n\t\t\tObject.keys(source.content.storedNames).forEach(name => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext(chunk => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map(source => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map(source => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach(source => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty () {\n\t\tif (this.intro.length && this.intro.trim())\n\t\t\treturn false;\n\t\tif (this.sources.some(source => !source.content.isEmpty()))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce((length, source) => length + source.content.length(), this.intro.length);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}