{"ast":null,"code":"import Prism from '../prism/index.js';\nexport { default as Prism } from '../prism/index.js';\nimport theme from '../themes/duotoneDark';\nimport { Component } from 'react';\nvar defaultProps = {\n  // $FlowFixMe\n  Prism: Prism,\n  theme: theme\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function (line) {\n  if (line.length === 0) {\n    line.push({\n      types: [\"plain\"],\n      content: \"\",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === \"\") {\n    line[0].empty = true;\n  }\n};\n\nvar appendTypes = function (types, add) {\n  var typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\n\n\nvar normalizeTokens = function (tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === \"string\") {\n        types = stackIndex > 0 ? types : [\"plain\"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n\n      if (typeof content !== \"string\") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var i$1 = 1; i$1 < newlineCount; i$1++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[i$1]\n        });\n      }\n    } // Decreate the stack depth\n\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nvar themeToDict = function (theme, language) {\n  var plain = theme.plain; // $FlowFixMe\n\n  var base = Object.create(null);\n  var themeDict = theme.styles.reduce(function (acc, themeEntry) {\n    var languages = themeEntry.languages;\n    var style = themeEntry.style;\n\n    if (languages && !languages.includes(language)) {\n      return acc;\n    }\n\n    themeEntry.types.forEach(function (type) {\n      // $FlowFixMe\n      var accStyle = _extends({}, acc[type], style);\n\n      acc[type] = accStyle;\n    });\n    return acc;\n  }, base); // $FlowFixMe\n\n  themeDict.root = plain; // $FlowFixMe\n\n  themeDict.plain = _extends({}, plain, {\n    backgroundColor: null\n  });\n  return themeDict;\n};\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n\n  return target;\n}\n\nvar Highlight = /*@__PURE__*/function (Component) {\n  function Highlight() {\n    var this$1 = this;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    Component.apply(this, args);\n\n    _defineProperty(this, \"getThemeDict\", function (props) {\n      if (this$1.themeDict !== undefined && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {\n        return this$1.themeDict;\n      }\n\n      this$1.prevTheme = props.theme;\n      this$1.prevLanguage = props.language;\n      var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;\n      return this$1.themeDict = themeDict;\n    });\n\n    _defineProperty(this, \"getLineProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"line\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token-line\",\n        style: undefined,\n        key: undefined\n      });\n\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict !== undefined) {\n        output.style = themeDict.plain;\n      }\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"getStyleForToken\", function (ref) {\n      var types = ref.types;\n      var empty = ref.empty;\n      var typesSize = types.length;\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict === undefined) {\n        return undefined;\n      } else if (typesSize === 1 && types[0] === \"plain\") {\n        return empty ? {\n          display: \"inline-block\"\n        } : undefined;\n      } else if (typesSize === 1 && !empty) {\n        return themeDict[types[0]];\n      }\n\n      var baseStyle = empty ? {\n        display: \"inline-block\"\n      } : {}; // $FlowFixMe\n\n      var typeStyles = types.map(function (type) {\n        return themeDict[type];\n      });\n      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));\n    });\n\n    _defineProperty(this, \"getTokenProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var token = ref.token;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"token\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token \" + token.types.join(\" \"),\n        children: token.content,\n        style: this$1.getStyleForToken(token),\n        key: undefined\n      });\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n  }\n\n  if (Component) Highlight.__proto__ = Component;\n  Highlight.prototype = Object.create(Component && Component.prototype);\n  Highlight.prototype.constructor = Highlight;\n\n  Highlight.prototype.render = function render() {\n    var ref = this.props;\n    var Prism = ref.Prism;\n    var language = ref.language;\n    var code = ref.code;\n    var children = ref.children;\n    var themeDict = this.getThemeDict(this.props);\n    var grammar = Prism.languages[language];\n    var mixedTokens = grammar !== undefined ? Prism.tokenize(code, grammar, language) : [code];\n    var tokens = normalizeTokens(mixedTokens);\n    return children({\n      tokens: tokens,\n      className: \"prism-code language-\" + language,\n      style: themeDict !== undefined ? themeDict.root : {},\n      getLineProps: this.getLineProps,\n      getTokenProps: this.getTokenProps\n    });\n  };\n\n  return Highlight;\n}(Component);\n\nexport default Highlight;\nexport { defaultProps };","map":{"version":3,"sources":["/Users/MihirBafna/Downloads/volt-react-dashboard-v1.0.0/node_modules/prism-react-renderer/dist/index.js"],"names":["Prism","default","theme","Component","defaultProps","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_extends","assign","target","i","arguments","length","source","prototype","hasOwnProperty","call","apply","newlineRe","normalizeEmptyLines","line","push","types","content","empty","appendTypes","add","typesSize","concat","normalizeTokens","tokens","typeArrStack","tokenArrStack","tokenArrIndexStack","tokenArrSizeStack","stackIndex","currentLine","acc","tokenArr","token","type","alias","splitByNewlines","split","newlineCount","i$1","pop","themeToDict","language","plain","base","create","themeDict","styles","reduce","themeEntry","languages","style","includes","forEach","accStyle","root","backgroundColor","objectWithoutProperties","exclude","k","indexOf","Highlight","this$1","args","len","props","undefined","prevTheme","prevLanguage","ref","className","rest$1","rest","output","getThemeDict","display","baseStyle","typeStyles","map","join","children","getStyleForToken","__proto__","constructor","render","code","grammar","mixedTokens","tokenize","getLineProps","getTokenProps"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,mBAAlB;AACA,SAASC,OAAO,IAAID,KAApB,QAAiC,mBAAjC;AACA,OAAOE,KAAP,MAAkB,uBAAlB;AACA,SAASC,SAAT,QAA0B,OAA1B;AAEA,IAAIC,YAAY,GAAG;AACjB;AACAJ,EAAAA,KAAK,EAAEA,KAFU;AAGjBE,EAAAA,KAAK,EAAEA;AAHU,CAAnB;;AAMA,SAASG,eAAT,CAAyBC,GAAzB,EAA8BC,GAA9B,EAAmCC,KAAnC,EAA0C;AACxC,MAAID,GAAG,IAAID,GAAX,EAAgB;AACdG,IAAAA,MAAM,CAACC,cAAP,CAAsBJ,GAAtB,EAA2BC,GAA3B,EAAgC;AAC9BC,MAAAA,KAAK,EAAEA,KADuB;AAE9BG,MAAAA,UAAU,EAAE,IAFkB;AAG9BC,MAAAA,YAAY,EAAE,IAHgB;AAI9BC,MAAAA,QAAQ,EAAE;AAJoB,KAAhC;AAMD,GAPD,MAOO;AACLP,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWC,KAAX;AACD;;AAED,SAAOF,GAAP;AACD;;AAED,SAASQ,QAAT,GAAoB;AAClBA,EAAAA,QAAQ,GAAGL,MAAM,CAACM,MAAP,IAAiB,UAAUC,MAAV,EAAkB;AAC5C,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AACzC,UAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAtB;;AAEA,WAAK,IAAIV,GAAT,IAAgBa,MAAhB,EAAwB;AACtB,YAAIX,MAAM,CAACY,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCH,MAArC,EAA6Cb,GAA7C,CAAJ,EAAuD;AACrDS,UAAAA,MAAM,CAACT,GAAD,CAAN,GAAca,MAAM,CAACb,GAAD,CAApB;AACD;AACF;AACF;;AAED,WAAOS,MAAP;AACD,GAZD;;AAcA,SAAOF,QAAQ,CAACU,KAAT,CAAe,IAAf,EAAqBN,SAArB,CAAP;AACD;;AAED,IAAIO,SAAS,GAAG,YAAhB,C,CAA8B;;AAE9B,IAAIC,mBAAmB,GAAG,UAAUC,IAAV,EAAgB;AACxC,MAAIA,IAAI,CAACR,MAAL,KAAgB,CAApB,EAAuB;AACrBQ,IAAAA,IAAI,CAACC,IAAL,CAAU;AACRC,MAAAA,KAAK,EAAE,CAAC,OAAD,CADC;AAERC,MAAAA,OAAO,EAAE,EAFD;AAGRC,MAAAA,KAAK,EAAE;AAHC,KAAV;AAKD,GAND,MAMO,IAAIJ,IAAI,CAACR,MAAL,KAAgB,CAAhB,IAAqBQ,IAAI,CAAC,CAAD,CAAJ,CAAQG,OAAR,KAAoB,EAA7C,EAAiD;AACtDH,IAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQI,KAAR,GAAgB,IAAhB;AACD;AACF,CAVD;;AAYA,IAAIC,WAAW,GAAG,UAAUH,KAAV,EAAiBI,GAAjB,EAAsB;AACtC,MAAIC,SAAS,GAAGL,KAAK,CAACV,MAAtB;;AAEA,MAAIe,SAAS,GAAG,CAAZ,IAAiBL,KAAK,CAACK,SAAS,GAAG,CAAb,CAAL,KAAyBD,GAA9C,EAAmD;AACjD,WAAOJ,KAAP;AACD;;AAED,SAAOA,KAAK,CAACM,MAAN,CAAaF,GAAb,CAAP;AACD,CARD,C,CAQG;AACH;AACA;AACA;AACA;AACA;;;AAGA,IAAIG,eAAe,GAAG,UAAUC,MAAV,EAAkB;AACtC,MAAIC,YAAY,GAAG,CAAC,EAAD,CAAnB;AACA,MAAIC,aAAa,GAAG,CAACF,MAAD,CAApB;AACA,MAAIG,kBAAkB,GAAG,CAAC,CAAD,CAAzB;AACA,MAAIC,iBAAiB,GAAG,CAACJ,MAAM,CAAClB,MAAR,CAAxB;AACA,MAAIF,CAAC,GAAG,CAAR;AACA,MAAIyB,UAAU,GAAG,CAAjB;AACA,MAAIC,WAAW,GAAG,EAAlB;AACA,MAAIC,GAAG,GAAG,CAACD,WAAD,CAAV;;AAEA,SAAOD,UAAU,GAAG,CAAC,CAArB,EAAwB;AACtB,WAAO,CAACzB,CAAC,GAAGuB,kBAAkB,CAACE,UAAD,CAAlB,EAAL,IAAyCD,iBAAiB,CAACC,UAAD,CAAjE,EAA+E;AAC7E,UAAIZ,OAAO,GAAG,KAAK,CAAnB;AACA,UAAID,KAAK,GAAGS,YAAY,CAACI,UAAD,CAAxB;AACA,UAAIG,QAAQ,GAAGN,aAAa,CAACG,UAAD,CAA5B;AACA,UAAII,KAAK,GAAGD,QAAQ,CAAC5B,CAAD,CAApB,CAJ6E,CAIpD;;AAEzB,UAAI,OAAO6B,KAAP,KAAiB,QAArB,EAA+B;AAC7BjB,QAAAA,KAAK,GAAGa,UAAU,GAAG,CAAb,GAAiBb,KAAjB,GAAyB,CAAC,OAAD,CAAjC;AACAC,QAAAA,OAAO,GAAGgB,KAAV;AACD,OAHD,MAGO;AACLjB,QAAAA,KAAK,GAAGG,WAAW,CAACH,KAAD,EAAQiB,KAAK,CAACC,IAAd,CAAnB;;AAEA,YAAID,KAAK,CAACE,KAAV,EAAiB;AACfnB,UAAAA,KAAK,GAAGG,WAAW,CAACH,KAAD,EAAQiB,KAAK,CAACE,KAAd,CAAnB;AACD;;AAEDlB,QAAAA,OAAO,GAAGgB,KAAK,CAAChB,OAAhB;AACD,OAjB4E,CAiB3E;;;AAGF,UAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/BY,QAAAA,UAAU;AACVJ,QAAAA,YAAY,CAACV,IAAb,CAAkBC,KAAlB;AACAU,QAAAA,aAAa,CAACX,IAAd,CAAmBE,OAAnB;AACAU,QAAAA,kBAAkB,CAACZ,IAAnB,CAAwB,CAAxB;AACAa,QAAAA,iBAAiB,CAACb,IAAlB,CAAuBE,OAAO,CAACX,MAA/B;AACA;AACD,OA3B4E,CA2B3E;;;AAGF,UAAI8B,eAAe,GAAGnB,OAAO,CAACoB,KAAR,CAAczB,SAAd,CAAtB;AACA,UAAI0B,YAAY,GAAGF,eAAe,CAAC9B,MAAnC;AACAwB,MAAAA,WAAW,CAACf,IAAZ,CAAiB;AACfC,QAAAA,KAAK,EAAEA,KADQ;AAEfC,QAAAA,OAAO,EAAEmB,eAAe,CAAC,CAAD;AAFT,OAAjB,EAhC6E,CAmCzE;;AAEJ,WAAK,IAAIG,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGD,YAAxB,EAAsCC,GAAG,EAAzC,EAA6C;AAC3C1B,QAAAA,mBAAmB,CAACiB,WAAD,CAAnB;AACAC,QAAAA,GAAG,CAAChB,IAAJ,CAASe,WAAW,GAAG,EAAvB;AACAA,QAAAA,WAAW,CAACf,IAAZ,CAAiB;AACfC,UAAAA,KAAK,EAAEA,KADQ;AAEfC,UAAAA,OAAO,EAAEmB,eAAe,CAACG,GAAD;AAFT,SAAjB;AAID;AACF,KA9CqB,CA8CpB;;;AAGFV,IAAAA,UAAU;AACVJ,IAAAA,YAAY,CAACe,GAAb;AACAd,IAAAA,aAAa,CAACc,GAAd;AACAb,IAAAA,kBAAkB,CAACa,GAAnB;AACAZ,IAAAA,iBAAiB,CAACY,GAAlB;AACD;;AAED3B,EAAAA,mBAAmB,CAACiB,WAAD,CAAnB;AACA,SAAOC,GAAP;AACD,CApED;;AAsEA,IAAIU,WAAW,GAAG,UAAUpD,KAAV,EAAiBqD,QAAjB,EAA2B;AAC3C,MAAIC,KAAK,GAAGtD,KAAK,CAACsD,KAAlB,CAD2C,CAClB;;AAEzB,MAAIC,IAAI,GAAGhD,MAAM,CAACiD,MAAP,CAAc,IAAd,CAAX;AACA,MAAIC,SAAS,GAAGzD,KAAK,CAAC0D,MAAN,CAAaC,MAAb,CAAoB,UAAUjB,GAAV,EAAekB,UAAf,EAA2B;AAC7D,QAAIC,SAAS,GAAGD,UAAU,CAACC,SAA3B;AACA,QAAIC,KAAK,GAAGF,UAAU,CAACE,KAAvB;;AAEA,QAAID,SAAS,IAAI,CAACA,SAAS,CAACE,QAAV,CAAmBV,QAAnB,CAAlB,EAAgD;AAC9C,aAAOX,GAAP;AACD;;AAEDkB,IAAAA,UAAU,CAACjC,KAAX,CAAiBqC,OAAjB,CAAyB,UAAUnB,IAAV,EAAgB;AACvC;AACA,UAAIoB,QAAQ,GAAGrD,QAAQ,CAAC,EAAD,EAAK8B,GAAG,CAACG,IAAD,CAAR,EAAgBiB,KAAhB,CAAvB;;AAEApB,MAAAA,GAAG,CAACG,IAAD,CAAH,GAAYoB,QAAZ;AACD,KALD;AAMA,WAAOvB,GAAP;AACD,GAfe,EAeba,IAfa,CAAhB,CAJ2C,CAmBjC;;AAEVE,EAAAA,SAAS,CAACS,IAAV,GAAiBZ,KAAjB,CArB2C,CAqBnB;;AAExBG,EAAAA,SAAS,CAACH,KAAV,GAAkB1C,QAAQ,CAAC,EAAD,EAAK0C,KAAL,EAAY;AACpCa,IAAAA,eAAe,EAAE;AADmB,GAAZ,CAA1B;AAGA,SAAOV,SAAP;AACD,CA3BD;;AA6BA,SAASW,uBAAT,CAAiChE,GAAjC,EAAsCiE,OAAtC,EAA+C;AAC7C,MAAIvD,MAAM,GAAG,EAAb;;AAEA,OAAK,IAAIwD,CAAT,IAAclE,GAAd,EAAmB,IAAIG,MAAM,CAACY,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCjB,GAArC,EAA0CkE,CAA1C,KAAgDD,OAAO,CAACE,OAAR,CAAgBD,CAAhB,MAAuB,CAAC,CAA5E,EAA+ExD,MAAM,CAACwD,CAAD,CAAN,GAAYlE,GAAG,CAACkE,CAAD,CAAf;;AAElG,SAAOxD,MAAP;AACD;;AAED,IAAI0D,SAAS,GACb,aACA,UAAUvE,SAAV,EAAqB;AACnB,WAASuE,SAAT,GAAqB;AACnB,QAAIC,MAAM,GAAG,IAAb;AACA,QAAIC,IAAI,GAAG,EAAX;AAAA,QACIC,GAAG,GAAG3D,SAAS,CAACC,MADpB;;AAGA,WAAO0D,GAAG,EAAV,EAAcD,IAAI,CAACC,GAAD,CAAJ,GAAY3D,SAAS,CAAC2D,GAAD,CAArB;;AAEd1E,IAAAA,SAAS,CAACqB,KAAV,CAAgB,IAAhB,EAAsBoD,IAAtB;;AAEAvE,IAAAA,eAAe,CAAC,IAAD,EAAO,cAAP,EAAuB,UAAUyE,KAAV,EAAiB;AACrD,UAAIH,MAAM,CAAChB,SAAP,KAAqBoB,SAArB,IAAkCD,KAAK,CAAC5E,KAAN,KAAgByE,MAAM,CAACK,SAAzD,IAAsEF,KAAK,CAACvB,QAAN,KAAmBoB,MAAM,CAACM,YAApG,EAAkH;AAChH,eAAON,MAAM,CAAChB,SAAd;AACD;;AAEDgB,MAAAA,MAAM,CAACK,SAAP,GAAmBF,KAAK,CAAC5E,KAAzB;AACAyE,MAAAA,MAAM,CAACM,YAAP,GAAsBH,KAAK,CAACvB,QAA5B;AACA,UAAII,SAAS,GAAGmB,KAAK,CAAC5E,KAAN,GAAcoD,WAAW,CAACwB,KAAK,CAAC5E,KAAP,EAAc4E,KAAK,CAACvB,QAApB,CAAzB,GAAyDwB,SAAzE;AACA,aAAOJ,MAAM,CAAChB,SAAP,GAAmBA,SAA1B;AACD,KATc,CAAf;;AAWAtD,IAAAA,eAAe,CAAC,IAAD,EAAO,cAAP,EAAuB,UAAU6E,GAAV,EAAe;AACnD,UAAI3E,GAAG,GAAG2E,GAAG,CAAC3E,GAAd;AACA,UAAI4E,SAAS,GAAGD,GAAG,CAACC,SAApB;AACA,UAAInB,KAAK,GAAGkB,GAAG,CAAClB,KAAhB;AACA,UAAIoB,MAAM,GAAGd,uBAAuB,CAACY,GAAD,EAAM,CAAC,KAAD,EAAQ,WAAR,EAAqB,OAArB,EAA8B,MAA9B,CAAN,CAApC;AACA,UAAIG,IAAI,GAAGD,MAAX;;AAEA,UAAIE,MAAM,GAAGxE,QAAQ,CAAC,EAAD,EAAKuE,IAAL,EAAW;AAC9BF,QAAAA,SAAS,EAAE,YADmB;AAE9BnB,QAAAA,KAAK,EAAEe,SAFuB;AAG9BxE,QAAAA,GAAG,EAAEwE;AAHyB,OAAX,CAArB;;AAMA,UAAIpB,SAAS,GAAGgB,MAAM,CAACY,YAAP,CAAoBZ,MAAM,CAACG,KAA3B,CAAhB;;AAEA,UAAInB,SAAS,KAAKoB,SAAlB,EAA6B;AAC3BO,QAAAA,MAAM,CAACtB,KAAP,GAAeL,SAAS,CAACH,KAAzB;AACD;;AAED,UAAIQ,KAAK,KAAKe,SAAd,EAAyB;AACvBO,QAAAA,MAAM,CAACtB,KAAP,GAAesB,MAAM,CAACtB,KAAP,KAAiBe,SAAjB,GAA6BjE,QAAQ,CAAC,EAAD,EAAKwE,MAAM,CAACtB,KAAZ,EAAmBA,KAAnB,CAArC,GAAiEA,KAAhF;AACD;;AAED,UAAIzD,GAAG,KAAKwE,SAAZ,EAAuB;AACrBO,QAAAA,MAAM,CAAC/E,GAAP,GAAaA,GAAb;AACD;;AAED,UAAI4E,SAAJ,EAAe;AACbG,QAAAA,MAAM,CAACH,SAAP,IAAoB,MAAMA,SAA1B;AACD;;AAED,aAAOG,MAAP;AACD,KAhCc,CAAf;;AAkCAjF,IAAAA,eAAe,CAAC,IAAD,EAAO,kBAAP,EAA2B,UAAU6E,GAAV,EAAe;AACvD,UAAIrD,KAAK,GAAGqD,GAAG,CAACrD,KAAhB;AACA,UAAIE,KAAK,GAAGmD,GAAG,CAACnD,KAAhB;AACA,UAAIG,SAAS,GAAGL,KAAK,CAACV,MAAtB;AACA,UAAIwC,SAAS,GAAGgB,MAAM,CAACY,YAAP,CAAoBZ,MAAM,CAACG,KAA3B,CAAhB;;AAEA,UAAInB,SAAS,KAAKoB,SAAlB,EAA6B;AAC3B,eAAOA,SAAP;AACD,OAFD,MAEO,IAAI7C,SAAS,KAAK,CAAd,IAAmBL,KAAK,CAAC,CAAD,CAAL,KAAa,OAApC,EAA6C;AAClD,eAAOE,KAAK,GAAG;AACbyD,UAAAA,OAAO,EAAE;AADI,SAAH,GAERT,SAFJ;AAGD,OAJM,MAIA,IAAI7C,SAAS,KAAK,CAAd,IAAmB,CAACH,KAAxB,EAA+B;AACpC,eAAO4B,SAAS,CAAC9B,KAAK,CAAC,CAAD,CAAN,CAAhB;AACD;;AAED,UAAI4D,SAAS,GAAG1D,KAAK,GAAG;AACtByD,QAAAA,OAAO,EAAE;AADa,OAAH,GAEjB,EAFJ,CAhBuD,CAkB/C;;AAER,UAAIE,UAAU,GAAG7D,KAAK,CAAC8D,GAAN,CAAU,UAAU5C,IAAV,EAAgB;AACzC,eAAOY,SAAS,CAACZ,IAAD,CAAhB;AACD,OAFgB,CAAjB;AAGA,aAAOtC,MAAM,CAACM,MAAP,CAAcS,KAAd,CAAoBf,MAApB,EAA4B,CAACgF,SAAD,EAAYtD,MAAZ,CAAmBuD,UAAnB,CAA5B,CAAP;AACD,KAxBc,CAAf;;AA0BArF,IAAAA,eAAe,CAAC,IAAD,EAAO,eAAP,EAAwB,UAAU6E,GAAV,EAAe;AACpD,UAAI3E,GAAG,GAAG2E,GAAG,CAAC3E,GAAd;AACA,UAAI4E,SAAS,GAAGD,GAAG,CAACC,SAApB;AACA,UAAInB,KAAK,GAAGkB,GAAG,CAAClB,KAAhB;AACA,UAAIlB,KAAK,GAAGoC,GAAG,CAACpC,KAAhB;AACA,UAAIsC,MAAM,GAAGd,uBAAuB,CAACY,GAAD,EAAM,CAAC,KAAD,EAAQ,WAAR,EAAqB,OAArB,EAA8B,OAA9B,CAAN,CAApC;AACA,UAAIG,IAAI,GAAGD,MAAX;;AAEA,UAAIE,MAAM,GAAGxE,QAAQ,CAAC,EAAD,EAAKuE,IAAL,EAAW;AAC9BF,QAAAA,SAAS,EAAE,WAAWrC,KAAK,CAACjB,KAAN,CAAY+D,IAAZ,CAAiB,GAAjB,CADQ;AAE9BC,QAAAA,QAAQ,EAAE/C,KAAK,CAAChB,OAFc;AAG9BkC,QAAAA,KAAK,EAAEW,MAAM,CAACmB,gBAAP,CAAwBhD,KAAxB,CAHuB;AAI9BvC,QAAAA,GAAG,EAAEwE;AAJyB,OAAX,CAArB;;AAOA,UAAIf,KAAK,KAAKe,SAAd,EAAyB;AACvBO,QAAAA,MAAM,CAACtB,KAAP,GAAesB,MAAM,CAACtB,KAAP,KAAiBe,SAAjB,GAA6BjE,QAAQ,CAAC,EAAD,EAAKwE,MAAM,CAACtB,KAAZ,EAAmBA,KAAnB,CAArC,GAAiEA,KAAhF;AACD;;AAED,UAAIzD,GAAG,KAAKwE,SAAZ,EAAuB;AACrBO,QAAAA,MAAM,CAAC/E,GAAP,GAAaA,GAAb;AACD;;AAED,UAAI4E,SAAJ,EAAe;AACbG,QAAAA,MAAM,CAACH,SAAP,IAAoB,MAAMA,SAA1B;AACD;;AAED,aAAOG,MAAP;AACD,KA5Bc,CAAf;AA6BD;;AAED,MAAInF,SAAJ,EAAeuE,SAAS,CAACqB,SAAV,GAAsB5F,SAAtB;AACfuE,EAAAA,SAAS,CAACrD,SAAV,GAAsBZ,MAAM,CAACiD,MAAP,CAAcvD,SAAS,IAAIA,SAAS,CAACkB,SAArC,CAAtB;AACAqD,EAAAA,SAAS,CAACrD,SAAV,CAAoB2E,WAApB,GAAkCtB,SAAlC;;AAEAA,EAAAA,SAAS,CAACrD,SAAV,CAAoB4E,MAApB,GAA6B,SAASA,MAAT,GAAkB;AAC7C,QAAIf,GAAG,GAAG,KAAKJ,KAAf;AACA,QAAI9E,KAAK,GAAGkF,GAAG,CAAClF,KAAhB;AACA,QAAIuD,QAAQ,GAAG2B,GAAG,CAAC3B,QAAnB;AACA,QAAI2C,IAAI,GAAGhB,GAAG,CAACgB,IAAf;AACA,QAAIL,QAAQ,GAAGX,GAAG,CAACW,QAAnB;AACA,QAAIlC,SAAS,GAAG,KAAK4B,YAAL,CAAkB,KAAKT,KAAvB,CAAhB;AACA,QAAIqB,OAAO,GAAGnG,KAAK,CAAC+D,SAAN,CAAgBR,QAAhB,CAAd;AACA,QAAI6C,WAAW,GAAGD,OAAO,KAAKpB,SAAZ,GAAwB/E,KAAK,CAACqG,QAAN,CAAeH,IAAf,EAAqBC,OAArB,EAA8B5C,QAA9B,CAAxB,GAAkE,CAAC2C,IAAD,CAApF;AACA,QAAI7D,MAAM,GAAGD,eAAe,CAACgE,WAAD,CAA5B;AACA,WAAOP,QAAQ,CAAC;AACdxD,MAAAA,MAAM,EAAEA,MADM;AAEd8C,MAAAA,SAAS,EAAE,yBAAyB5B,QAFtB;AAGdS,MAAAA,KAAK,EAAEL,SAAS,KAAKoB,SAAd,GAA0BpB,SAAS,CAACS,IAApC,GAA2C,EAHpC;AAIdkC,MAAAA,YAAY,EAAE,KAAKA,YAJL;AAKdC,MAAAA,aAAa,EAAE,KAAKA;AALN,KAAD,CAAf;AAOD,GAjBD;;AAmBA,SAAO7B,SAAP;AACD,CAxID,CAwIEvE,SAxIF,CAFA;;AA4IA,eAAeuE,SAAf;AACA,SAAStE,YAAT","sourcesContent":["import Prism from '../prism/index.js';\nexport { default as Prism } from '../prism/index.js';\nimport theme from '../themes/duotoneDark';\nimport { Component } from 'react';\n\nvar defaultProps = {\n  // $FlowFixMe\n  Prism: Prism,\n  theme: theme\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function (line) {\n  if (line.length === 0) {\n    line.push({\n      types: [\"plain\"],\n      content: \"\",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === \"\") {\n    line[0].empty = true;\n  }\n};\n\nvar appendTypes = function (types, add) {\n  var typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\n\n\nvar normalizeTokens = function (tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === \"string\") {\n        types = stackIndex > 0 ? types : [\"plain\"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n\n      if (typeof content !== \"string\") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var i$1 = 1; i$1 < newlineCount; i$1++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[i$1]\n        });\n      }\n    } // Decreate the stack depth\n\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nvar themeToDict = function (theme, language) {\n  var plain = theme.plain; // $FlowFixMe\n\n  var base = Object.create(null);\n  var themeDict = theme.styles.reduce(function (acc, themeEntry) {\n    var languages = themeEntry.languages;\n    var style = themeEntry.style;\n\n    if (languages && !languages.includes(language)) {\n      return acc;\n    }\n\n    themeEntry.types.forEach(function (type) {\n      // $FlowFixMe\n      var accStyle = _extends({}, acc[type], style);\n\n      acc[type] = accStyle;\n    });\n    return acc;\n  }, base); // $FlowFixMe\n\n  themeDict.root = plain; // $FlowFixMe\n\n  themeDict.plain = _extends({}, plain, {\n    backgroundColor: null\n  });\n  return themeDict;\n};\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n\n  return target;\n}\n\nvar Highlight =\n/*@__PURE__*/\nfunction (Component) {\n  function Highlight() {\n    var this$1 = this;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    Component.apply(this, args);\n\n    _defineProperty(this, \"getThemeDict\", function (props) {\n      if (this$1.themeDict !== undefined && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {\n        return this$1.themeDict;\n      }\n\n      this$1.prevTheme = props.theme;\n      this$1.prevLanguage = props.language;\n      var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;\n      return this$1.themeDict = themeDict;\n    });\n\n    _defineProperty(this, \"getLineProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"line\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token-line\",\n        style: undefined,\n        key: undefined\n      });\n\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict !== undefined) {\n        output.style = themeDict.plain;\n      }\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"getStyleForToken\", function (ref) {\n      var types = ref.types;\n      var empty = ref.empty;\n      var typesSize = types.length;\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict === undefined) {\n        return undefined;\n      } else if (typesSize === 1 && types[0] === \"plain\") {\n        return empty ? {\n          display: \"inline-block\"\n        } : undefined;\n      } else if (typesSize === 1 && !empty) {\n        return themeDict[types[0]];\n      }\n\n      var baseStyle = empty ? {\n        display: \"inline-block\"\n      } : {}; // $FlowFixMe\n\n      var typeStyles = types.map(function (type) {\n        return themeDict[type];\n      });\n      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));\n    });\n\n    _defineProperty(this, \"getTokenProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var token = ref.token;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"token\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token \" + token.types.join(\" \"),\n        children: token.content,\n        style: this$1.getStyleForToken(token),\n        key: undefined\n      });\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n  }\n\n  if (Component) Highlight.__proto__ = Component;\n  Highlight.prototype = Object.create(Component && Component.prototype);\n  Highlight.prototype.constructor = Highlight;\n\n  Highlight.prototype.render = function render() {\n    var ref = this.props;\n    var Prism = ref.Prism;\n    var language = ref.language;\n    var code = ref.code;\n    var children = ref.children;\n    var themeDict = this.getThemeDict(this.props);\n    var grammar = Prism.languages[language];\n    var mixedTokens = grammar !== undefined ? Prism.tokenize(code, grammar, language) : [code];\n    var tokens = normalizeTokens(mixedTokens);\n    return children({\n      tokens: tokens,\n      className: \"prism-code language-\" + language,\n      style: themeDict !== undefined ? themeDict.root : {},\n      getLineProps: this.getLineProps,\n      getTokenProps: this.getTokenProps\n    });\n  };\n\n  return Highlight;\n}(Component);\n\nexport default Highlight;\nexport { defaultProps };\n"]},"metadata":{},"sourceType":"module"}