{"ast":null,"code":"var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfor (var i = 0; i < chars.length; i++) {\n  charToInteger[chars.charCodeAt(i)] = i;\n}\n\nfunction decode(mappings) {\n  var decoded = [];\n  var line = [];\n  var segment = [0, 0, 0, 0, 0];\n  var j = 0;\n\n  for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n    var c = mappings.charCodeAt(i);\n\n    if (c === 44) {\n      // \",\"\n      segmentify(line, segment, j);\n      j = 0;\n    } else if (c === 59) {\n      // \";\"\n      segmentify(line, segment, j);\n      j = 0;\n      decoded.push(line);\n      line = [];\n      segment[0] = 0;\n    } else {\n      var integer = charToInteger[c];\n\n      if (integer === undefined) {\n        throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n      }\n\n      var hasContinuationBit = integer & 32;\n      integer &= 31;\n      value += integer << shift;\n\n      if (hasContinuationBit) {\n        shift += 5;\n      } else {\n        var shouldNegate = value & 1;\n        value >>>= 1;\n\n        if (shouldNegate) {\n          value = value === 0 ? -0x80000000 : -value;\n        }\n\n        segment[j] += value;\n        j++;\n        value = shift = 0; // reset\n      }\n    }\n  }\n\n  segmentify(line, segment, j);\n  decoded.push(line);\n  return decoded;\n}\n\nfunction segmentify(line, segment, j) {\n  // This looks ugly, but we're creating specialized arrays with a specific\n  // length. This is much faster than creating a new array (which v8 expands to\n  // a capacity of 17 after pushing the first item), or slicing out a subarray\n  // (which is slow). Length 4 is assumed to be the most frequent, followed by\n  // length 5 (since not everything will have an associated name), followed by\n  // length 1 (it's probably rare for a source substring to not have an\n  // associated segment data).\n  if (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);else if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);else if (j === 1) line.push([segment[0]]);\n}\n\nfunction encode(decoded) {\n  var sourceFileIndex = 0; // second field\n\n  var sourceCodeLine = 0; // third field\n\n  var sourceCodeColumn = 0; // fourth field\n\n  var nameIndex = 0; // fifth field\n\n  var mappings = '';\n\n  for (var i = 0; i < decoded.length; i++) {\n    var line = decoded[i];\n    if (i > 0) mappings += ';';\n    if (line.length === 0) continue;\n    var generatedCodeColumn = 0; // first field\n\n    var lineMappings = [];\n\n    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n      var segment = line_1[_i];\n      var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n      generatedCodeColumn = segment[0];\n\n      if (segment.length > 1) {\n        segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);\n        sourceFileIndex = segment[1];\n        sourceCodeLine = segment[2];\n        sourceCodeColumn = segment[3];\n      }\n\n      if (segment.length === 5) {\n        segmentMappings += encodeInteger(segment[4] - nameIndex);\n        nameIndex = segment[4];\n      }\n\n      lineMappings.push(segmentMappings);\n    }\n\n    mappings += lineMappings.join(',');\n  }\n\n  return mappings;\n}\n\nfunction encodeInteger(num) {\n  var result = '';\n  num = num < 0 ? -num << 1 | 1 : num << 1;\n\n  do {\n    var clamped = num & 31;\n    num >>>= 5;\n\n    if (num > 0) {\n      clamped |= 32;\n    }\n\n    result += chars[clamped];\n  } while (num > 0);\n\n  return result;\n}\n\nexport { decode, encode };","map":{"version":3,"sources":["../src/sourcemap-codec.ts"],"names":[],"mappings":"AAOA,IAAM,aAAa,GAAmC,EAAtD;AACA,IAAM,KAAK,GAAG,mEAAd;;AAEA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACtC,EAAA,aAAa,CAAC,KAAK,CAAC,UAAN,CAAiB,CAAjB,CAAD,CAAb,GAAqC,CAArC;AACA;;AAED,SAAgB,MAAhB,CAAuB,QAAvB,EAAuC;AACtC,MAAM,OAAO,GAAsB,EAAnC;AACA,MAAI,IAAI,GAAkB,EAA1B;AACA,MAAM,OAAO,GAAqB,CACjC,CADiC,EAEjC,CAFiC,EAGjC,CAHiC,EAIjC,CAJiC,EAKjC,CALiC,CAAlC;AAQA,MAAI,CAAC,GAAG,CAAR;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,KAAK,GAAG,CAAnB,EAAsB,KAAK,GAAG,CAAnC,EAAsC,CAAC,GAAG,QAAQ,CAAC,MAAnD,EAA2D,CAAC,EAA5D,EAAgE;AAC/D,QAAM,CAAC,GAAG,QAAQ,CAAC,UAAT,CAAoB,CAApB,CAAV;;AAEA,QAAI,CAAC,KAAK,EAAV,EAAc;AAAA;AACb,MAAA,UAAU,CAAC,IAAD,EAAO,OAAP,EAAgB,CAAhB,CAAV;AACA,MAAA,CAAC,GAAG,CAAJ;AAEA,KAJD,MAIO,IAAI,CAAC,KAAK,EAAV,EAAc;AAAA;AACpB,MAAA,UAAU,CAAC,IAAD,EAAO,OAAP,EAAgB,CAAhB,CAAV;AACA,MAAA,CAAC,GAAG,CAAJ;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,IAAb;AACA,MAAA,IAAI,GAAG,EAAP;AACA,MAAA,OAAO,CAAC,CAAD,CAAP,GAAa,CAAb;AAEA,KAPM,MAOA;AACN,UAAI,OAAO,GAAG,aAAa,CAAC,CAAD,CAA3B;;AACA,UAAI,OAAO,KAAK,SAAhB,EAA2B;AAC1B,cAAM,IAAI,KAAJ,CAAU,wBAAwB,MAAM,CAAC,YAAP,CAAoB,CAApB,CAAxB,GAAiD,GAA3D,CAAN;AACA;;AAED,UAAM,kBAAkB,GAAG,OAAO,GAAG,EAArC;AAEA,MAAA,OAAO,IAAI,EAAX;AACA,MAAA,KAAK,IAAI,OAAO,IAAI,KAApB;;AAEA,UAAI,kBAAJ,EAAwB;AACvB,QAAA,KAAK,IAAI,CAAT;AACA,OAFD,MAEO;AACN,YAAM,YAAY,GAAG,KAAK,GAAG,CAA7B;AACA,QAAA,KAAK,MAAM,CAAX;;AAEA,YAAI,YAAJ,EAAkB;AACjB,UAAA,KAAK,GAAG,KAAK,KAAK,CAAV,GAAc,CAAC,UAAf,GAA4B,CAAC,KAArC;AACA;;AAED,QAAA,OAAO,CAAC,CAAD,CAAP,IAAc,KAAd;AACA,QAAA,CAAC;AACD,QAAA,KAAK,GAAG,KAAK,GAAG,CAAhB,CAVM,CAUY;AAClB;AACD;AACD;;AAED,EAAA,UAAU,CAAC,IAAD,EAAO,OAAP,EAAgB,CAAhB,CAAV;AACA,EAAA,OAAO,CAAC,IAAR,CAAa,IAAb;AAEA,SAAO,OAAP;AACA;;AAED,SAAS,UAAT,CAAoB,IAApB,EAA8C,OAA9C,EAAyE,CAAzE,EAAkF;;;;;;;;AAQjF,MAAI,CAAC,KAAK,CAAV,EAAa,IAAI,CAAC,IAAL,CAAU,CAAC,OAAO,CAAC,CAAD,CAAR,EAAa,OAAO,CAAC,CAAD,CAApB,EAAyB,OAAO,CAAC,CAAD,CAAhC,EAAqC,OAAO,CAAC,CAAD,CAA5C,CAAV,EAAb,KACK,IAAI,CAAC,KAAK,CAAV,EAAa,IAAI,CAAC,IAAL,CAAU,CAAC,OAAO,CAAC,CAAD,CAAR,EAAa,OAAO,CAAC,CAAD,CAApB,EAAyB,OAAO,CAAC,CAAD,CAAhC,EAAqC,OAAO,CAAC,CAAD,CAA5C,EAAiD,OAAO,CAAC,CAAD,CAAxD,CAAV,EAAb,KACA,IAAI,CAAC,KAAK,CAAV,EAAa,IAAI,CAAC,IAAL,CAAU,CAAC,OAAO,CAAC,CAAD,CAAR,CAAV;AAClB;;AAED,SAAgB,MAAhB,CAAuB,OAAvB,EAAiD;AAChD,MAAI,eAAe,GAAG,CAAtB,CADgD,CACxB;;AACxB,MAAI,cAAc,GAAG,CAArB,CAFgD,CAEzB;;AACvB,MAAI,gBAAgB,GAAG,CAAvB,CAHgD,CAGvB;;AACzB,MAAI,SAAS,GAAG,CAAhB,CAJgD,CAI9B;;AAClB,MAAI,QAAQ,GAAG,EAAf;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,MAA5B,EAAoC,CAAC,EAArC,EAAyC;AACxC,QAAM,IAAI,GAAG,OAAO,CAAC,CAAD,CAApB;AACA,QAAI,CAAC,GAAG,CAAR,EAAW,QAAQ,IAAI,GAAZ;AACX,QAAI,IAAI,CAAC,MAAL,KAAgB,CAApB,EAAuB;AAEvB,QAAI,mBAAmB,GAAG,CAA1B,CALwC,CAKZ;;AAE5B,QAAM,YAAY,GAAa,EAA/B;;AAEA,SAAsB,IAAA,EAAA,GAAA,CAAA,EAAA,MAAA,GAAA,IAAtB,EAAsB,EAAA,GAAA,MAAA,CAAA,MAAtB,EAAsB,EAAA,EAAtB,EAA4B;AAAvB,UAAM,OAAO,GAAA,MAAA,CAAA,EAAA,CAAb;AACJ,UAAI,eAAe,GAAG,aAAa,CAAC,OAAO,CAAC,CAAD,CAAP,GAAa,mBAAd,CAAnC;AACA,MAAA,mBAAmB,GAAG,OAAO,CAAC,CAAD,CAA7B;;AAEA,UAAI,OAAO,CAAC,MAAR,GAAiB,CAArB,EAAwB;AACvB,QAAA,eAAe,IACd,aAAa,CAAC,OAAO,CAAC,CAAD,CAAP,GAAa,eAAd,CAAb,GACA,aAAa,CAAC,OAAO,CAAC,CAAD,CAAP,GAAa,cAAd,CADb,GAEA,aAAa,CAAC,OAAO,CAAC,CAAD,CAAP,GAAa,gBAAd,CAHd;AAKA,QAAA,eAAe,GAAG,OAAO,CAAC,CAAD,CAAzB;AACA,QAAA,cAAc,GAAG,OAAO,CAAC,CAAD,CAAxB;AACA,QAAA,gBAAgB,GAAG,OAAO,CAAC,CAAD,CAA1B;AACA;;AAED,UAAI,OAAO,CAAC,MAAR,KAAmB,CAAvB,EAA0B;AACzB,QAAA,eAAe,IAAI,aAAa,CAAC,OAAO,CAAC,CAAD,CAAP,GAAa,SAAd,CAAhC;AACA,QAAA,SAAS,GAAG,OAAO,CAAC,CAAD,CAAnB;AACA;;AAED,MAAA,YAAY,CAAC,IAAb,CAAkB,eAAlB;AACA;;AAED,IAAA,QAAQ,IAAI,YAAY,CAAC,IAAb,CAAkB,GAAlB,CAAZ;AACA;;AAED,SAAO,QAAP;AACA;;AAED,SAAS,aAAT,CAAuB,GAAvB,EAAkC;AACjC,MAAI,MAAM,GAAG,EAAb;AACA,EAAA,GAAG,GAAG,GAAG,GAAG,CAAN,GAAW,CAAC,GAAD,IAAQ,CAAT,GAAc,CAAxB,GAA4B,GAAG,IAAI,CAAzC;;AACA,KAAG;AACF,QAAI,OAAO,GAAG,GAAG,GAAG,EAApB;AACA,IAAA,GAAG,MAAM,CAAT;;AACA,QAAI,GAAG,GAAG,CAAV,EAAa;AACZ,MAAA,OAAO,IAAI,EAAX;AACA;;AACD,IAAA,MAAM,IAAI,KAAK,CAAC,OAAD,CAAf;AACA,GAPD,QAOS,GAAG,GAAG,CAPf;;AASA,SAAO,MAAP;AACA","sourcesContent":["export type SourceMapSegment =\n\t| [number]\n\t| [number, number, number, number]\n\t| [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nconst charToInteger: { [charCode: number]: number } = {};\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfor (let i = 0; i < chars.length; i++) {\n\tcharToInteger[chars.charCodeAt(i)] = i;\n}\n\nexport function decode(mappings: string): SourceMapMappings {\n\tconst decoded: SourceMapMappings = [];\n\tlet line: SourceMapLine = [];\n\tconst segment: SourceMapSegment = [\n\t\t0, // generated code column\n\t\t0, // source file index\n\t\t0, // source code line\n\t\t0, // source code column\n\t\t0, // name index\n\t];\n\n\tlet j = 0;\n\tfor (let i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n\t\tconst c = mappings.charCodeAt(i);\n\n\t\tif (c === 44) { // \",\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\n\t\t} else if (c === 59) { // \";\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\t\t\tdecoded.push(line);\n\t\t\tline = [];\n\t\t\tsegment[0] = 0;\n\n\t\t} else {\n\t\t\tlet integer = charToInteger[c];\n\t\t\tif (integer === undefined) {\n\t\t\t\tthrow new Error('Invalid character (' + String.fromCharCode(c) + ')');\n\t\t\t}\n\n\t\t\tconst hasContinuationBit = integer & 32;\n\n\t\t\tinteger &= 31;\n\t\t\tvalue += integer << shift;\n\n\t\t\tif (hasContinuationBit) {\n\t\t\t\tshift += 5;\n\t\t\t} else {\n\t\t\t\tconst shouldNegate = value & 1;\n\t\t\t\tvalue >>>= 1;\n\n\t\t\t\tif (shouldNegate) {\n\t\t\t\t\tvalue = value === 0 ? -0x80000000 : -value;\n\t\t\t\t}\n\n\t\t\t\tsegment[j] += value;\n\t\t\t\tj++;\n\t\t\t\tvalue = shift = 0; // reset\n\t\t\t}\n\t\t}\n\t}\n\n\tsegmentify(line, segment, j);\n\tdecoded.push(line);\n\n\treturn decoded;\n}\n\nfunction segmentify(line: SourceMapSegment[], segment: SourceMapSegment, j: number) {\n\t// This looks ugly, but we're creating specialized arrays with a specific\n\t// length. This is much faster than creating a new array (which v8 expands to\n\t// a capacity of 17 after pushing the first item), or slicing out a subarray\n\t// (which is slow). Length 4 is assumed to be the most frequent, followed by\n\t// length 5 (since not everything will have an associated name), followed by\n\t// length 1 (it's probably rare for a source substring to not have an\n\t// associated segment data).\n\tif (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);\n\telse if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n\telse if (j === 1) line.push([segment[0]]);\n}\n\nexport function encode(decoded: SourceMapMappings): string {\n\tlet sourceFileIndex = 0;  // second field\n\tlet sourceCodeLine = 0;   // third field\n\tlet sourceCodeColumn = 0; // fourth field\n\tlet nameIndex = 0;        // fifth field\n\tlet mappings = '';\n\n\tfor (let i = 0; i < decoded.length; i++) {\n\t\tconst line = decoded[i];\n\t\tif (i > 0) mappings += ';';\n\t\tif (line.length === 0) continue;\n\n\t\tlet generatedCodeColumn = 0; // first field\n\n\t\tconst lineMappings: string[] = [];\n\n\t\tfor (const segment of line) {\n\t\t\tlet segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n\t\t\tgeneratedCodeColumn = segment[0];\n\n\t\t\tif (segment.length > 1) {\n\t\t\t\tsegmentMappings +=\n\t\t\t\t\tencodeInteger(segment[1] - sourceFileIndex) +\n\t\t\t\t\tencodeInteger(segment[2] - sourceCodeLine) +\n\t\t\t\t\tencodeInteger(segment[3] - sourceCodeColumn);\n\n\t\t\t\tsourceFileIndex = segment[1];\n\t\t\t\tsourceCodeLine = segment[2];\n\t\t\t\tsourceCodeColumn = segment[3];\n\t\t\t}\n\n\t\t\tif (segment.length === 5) {\n\t\t\t\tsegmentMappings += encodeInteger(segment[4] - nameIndex);\n\t\t\t\tnameIndex = segment[4];\n\t\t\t}\n\n\t\t\tlineMappings.push(segmentMappings);\n\t\t}\n\n\t\tmappings += lineMappings.join(',');\n\t}\n\n\treturn mappings;\n}\n\nfunction encodeInteger(num: number): string {\n\tvar result = '';\n\tnum = num < 0 ? (-num << 1) | 1 : num << 1;\n\tdo {\n\t\tvar clamped = num & 31;\n\t\tnum >>>= 5;\n\t\tif (num > 0) {\n\t\t\tclamped |= 32;\n\t\t}\n\t\tresult += chars[clamped];\n\t} while (num > 0);\n\n\treturn result;\n}\n"]},"metadata":{},"sourceType":"module"}