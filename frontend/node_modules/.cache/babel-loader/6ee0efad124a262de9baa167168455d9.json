{"ast":null,"code":"/*! https://mths.be/regenerate v1.4.2 by @mathias | MIT license */\n;\n\n(function (root) {\n  // Detect free variables `exports`.\n  var freeExports = typeof exports == 'object' && exports; // Detect free variable `module`.\n\n  var freeModule = typeof module == 'object' && module && module.exports == freeExports && module; // Detect free variable `global`, from Node.js/io.js or Browserified code,\n  // and use it as `root`.\n\n  var freeGlobal = typeof global == 'object' && global;\n\n  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n    root = freeGlobal;\n  }\n  /*--------------------------------------------------------------------------*/\n\n\n  var ERRORS = {\n    'rangeOrder': 'A range\\u2019s `stop` value must be greater than or equal ' + 'to the `start` value.',\n    'codePointRange': 'Invalid code point value. Code points range from ' + 'U+000000 to U+10FFFF.'\n  }; // https://mathiasbynens.be/notes/javascript-encoding#surrogate-pairs\n\n  var HIGH_SURROGATE_MIN = 0xD800;\n  var HIGH_SURROGATE_MAX = 0xDBFF;\n  var LOW_SURROGATE_MIN = 0xDC00;\n  var LOW_SURROGATE_MAX = 0xDFFF; // In Regenerate output, `\\0` is never preceded by `\\` because we sort by\n  // code point value, so let’s keep this regular expression simple.\n\n  var regexNull = /\\\\x00([^0123456789]|$)/g;\n  var object = {};\n  var hasOwnProperty = object.hasOwnProperty;\n\n  var extend = function (destination, source) {\n    var key;\n\n    for (key in source) {\n      if (hasOwnProperty.call(source, key)) {\n        destination[key] = source[key];\n      }\n    }\n\n    return destination;\n  };\n\n  var forEach = function (array, callback) {\n    var index = -1;\n    var length = array.length;\n\n    while (++index < length) {\n      callback(array[index], index);\n    }\n  };\n\n  var toString = object.toString;\n\n  var isArray = function (value) {\n    return toString.call(value) == '[object Array]';\n  };\n\n  var isNumber = function (value) {\n    return typeof value == 'number' || toString.call(value) == '[object Number]';\n  }; // This assumes that `number` is a positive integer that `toString()`s nicely\n  // (which is the case for all code point values).\n\n\n  var zeroes = '0000';\n\n  var pad = function (number, totalCharacters) {\n    var string = String(number);\n    return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;\n  };\n\n  var hex = function (number) {\n    return Number(number).toString(16).toUpperCase();\n  };\n\n  var slice = [].slice;\n  /*--------------------------------------------------------------------------*/\n\n  var dataFromCodePoints = function (codePoints) {\n    var index = -1;\n    var length = codePoints.length;\n    var max = length - 1;\n    var result = [];\n    var isStart = true;\n    var tmp;\n    var previous = 0;\n\n    while (++index < length) {\n      tmp = codePoints[index];\n\n      if (isStart) {\n        result.push(tmp);\n        previous = tmp;\n        isStart = false;\n      } else {\n        if (tmp == previous + 1) {\n          if (index != max) {\n            previous = tmp;\n            continue;\n          } else {\n            isStart = true;\n            result.push(tmp + 1);\n          }\n        } else {\n          // End the previous range and start a new one.\n          result.push(previous + 1, tmp);\n          previous = tmp;\n        }\n      }\n    }\n\n    if (!isStart) {\n      result.push(tmp + 1);\n    }\n\n    return result;\n  };\n\n  var dataRemove = function (data, codePoint) {\n    // Iterate over the data per `(start, end)` pair.\n    var index = 0;\n    var start;\n    var end;\n    var length = data.length;\n\n    while (index < length) {\n      start = data[index];\n      end = data[index + 1];\n\n      if (codePoint >= start && codePoint < end) {\n        // Modify this pair.\n        if (codePoint == start) {\n          if (end == start + 1) {\n            // Just remove `start` and `end`.\n            data.splice(index, 2);\n            return data;\n          } else {\n            // Just replace `start` with a new value.\n            data[index] = codePoint + 1;\n            return data;\n          }\n        } else if (codePoint == end - 1) {\n          // Just replace `end` with a new value.\n          data[index + 1] = codePoint;\n          return data;\n        } else {\n          // Replace `[start, end]` with `[startA, endA, startB, endB]`.\n          data.splice(index, 2, start, codePoint, codePoint + 1, end);\n          return data;\n        }\n      }\n\n      index += 2;\n    }\n\n    return data;\n  };\n\n  var dataRemoveRange = function (data, rangeStart, rangeEnd) {\n    if (rangeEnd < rangeStart) {\n      throw Error(ERRORS.rangeOrder);\n    } // Iterate over the data per `(start, end)` pair.\n\n\n    var index = 0;\n    var start;\n    var end;\n\n    while (index < data.length) {\n      start = data[index];\n      end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.\n      // Exit as soon as no more matching pairs can be found.\n\n      if (start > rangeEnd) {\n        return data;\n      } // Check if this range pair is equal to, or forms a subset of, the range\n      // to be removed.\n      // E.g. we have `[0, 11, 40, 51]` and want to remove 0-10 → `[40, 51]`.\n      // E.g. we have `[40, 51]` and want to remove 0-100 → `[]`.\n\n\n      if (rangeStart <= start && rangeEnd >= end) {\n        // Remove this pair.\n        data.splice(index, 2);\n        continue;\n      } // Check if both `rangeStart` and `rangeEnd` are within the bounds of\n      // this pair.\n      // E.g. we have `[0, 11]` and want to remove 4-6 → `[0, 4, 7, 11]`.\n\n\n      if (rangeStart >= start && rangeEnd < end) {\n        if (rangeStart == start) {\n          // Replace `[start, end]` with `[startB, endB]`.\n          data[index] = rangeEnd + 1;\n          data[index + 1] = end + 1;\n          return data;\n        } // Replace `[start, end]` with `[startA, endA, startB, endB]`.\n\n\n        data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);\n        return data;\n      } // Check if only `rangeStart` is within the bounds of this pair.\n      // E.g. we have `[0, 11]` and want to remove 4-20 → `[0, 4]`.\n\n\n      if (rangeStart >= start && rangeStart <= end) {\n        // Replace `end` with `rangeStart`.\n        data[index + 1] = rangeStart; // Note: we cannot `return` just yet, in case any following pairs still\n        // contain matching code points.\n        // E.g. we have `[0, 11, 14, 31]` and want to remove 4-20\n        // → `[0, 4, 21, 31]`.\n      } // Check if only `rangeEnd` is within the bounds of this pair.\n      // E.g. we have `[14, 31]` and want to remove 4-20 → `[21, 31]`.\n      else if (rangeEnd >= start && rangeEnd <= end) {\n          // Just replace `start`.\n          data[index] = rangeEnd + 1;\n          return data;\n        }\n\n      index += 2;\n    }\n\n    return data;\n  };\n\n  var dataAdd = function (data, codePoint) {\n    // Iterate over the data per `(start, end)` pair.\n    var index = 0;\n    var start;\n    var end;\n    var lastIndex = null;\n    var length = data.length;\n\n    if (codePoint < 0x0 || codePoint > 0x10FFFF) {\n      throw RangeError(ERRORS.codePointRange);\n    }\n\n    while (index < length) {\n      start = data[index];\n      end = data[index + 1]; // Check if the code point is already in the set.\n\n      if (codePoint >= start && codePoint < end) {\n        return data;\n      }\n\n      if (codePoint == start - 1) {\n        // Just replace `start` with a new value.\n        data[index] = codePoint;\n        return data;\n      } // At this point, if `start` is `greater` than `codePoint`, insert a new\n      // `[start, end]` pair before the current pair, or after the current pair\n      // if there is a known `lastIndex`.\n\n\n      if (start > codePoint) {\n        data.splice(lastIndex != null ? lastIndex + 2 : 0, 0, codePoint, codePoint + 1);\n        return data;\n      }\n\n      if (codePoint == end) {\n        // Check if adding this code point causes two separate ranges to become\n        // a single range, e.g. `dataAdd([0, 4, 5, 10], 4)` → `[0, 10]`.\n        if (codePoint + 1 == data[index + 2]) {\n          data.splice(index, 4, start, data[index + 3]);\n          return data;\n        } // Else, just replace `end` with a new value.\n\n\n        data[index + 1] = codePoint + 1;\n        return data;\n      }\n\n      lastIndex = index;\n      index += 2;\n    } // The loop has finished; add the new pair to the end of the data set.\n\n\n    data.push(codePoint, codePoint + 1);\n    return data;\n  };\n\n  var dataAddData = function (dataA, dataB) {\n    // Iterate over the data per `(start, end)` pair.\n    var index = 0;\n    var start;\n    var end;\n    var data = dataA.slice();\n    var length = dataB.length;\n\n    while (index < length) {\n      start = dataB[index];\n      end = dataB[index + 1] - 1;\n\n      if (start == end) {\n        data = dataAdd(data, start);\n      } else {\n        data = dataAddRange(data, start, end);\n      }\n\n      index += 2;\n    }\n\n    return data;\n  };\n\n  var dataRemoveData = function (dataA, dataB) {\n    // Iterate over the data per `(start, end)` pair.\n    var index = 0;\n    var start;\n    var end;\n    var data = dataA.slice();\n    var length = dataB.length;\n\n    while (index < length) {\n      start = dataB[index];\n      end = dataB[index + 1] - 1;\n\n      if (start == end) {\n        data = dataRemove(data, start);\n      } else {\n        data = dataRemoveRange(data, start, end);\n      }\n\n      index += 2;\n    }\n\n    return data;\n  };\n\n  var dataAddRange = function (data, rangeStart, rangeEnd) {\n    if (rangeEnd < rangeStart) {\n      throw Error(ERRORS.rangeOrder);\n    }\n\n    if (rangeStart < 0x0 || rangeStart > 0x10FFFF || rangeEnd < 0x0 || rangeEnd > 0x10FFFF) {\n      throw RangeError(ERRORS.codePointRange);\n    } // Iterate over the data per `(start, end)` pair.\n\n\n    var index = 0;\n    var start;\n    var end;\n    var added = false;\n    var length = data.length;\n\n    while (index < length) {\n      start = data[index];\n      end = data[index + 1];\n\n      if (added) {\n        // The range has already been added to the set; at this point, we just\n        // need to get rid of the following ranges in case they overlap.\n        // Check if this range can be combined with the previous range.\n        if (start == rangeEnd + 1) {\n          data.splice(index - 1, 2);\n          return data;\n        } // Exit as soon as no more possibly overlapping pairs can be found.\n\n\n        if (start > rangeEnd) {\n          return data;\n        } // E.g. `[0, 11, 12, 16]` and we’ve added 5-15, so we now have\n        // `[0, 16, 12, 16]`. Remove the `12,16` part, as it lies within the\n        // `0,16` range that was previously added.\n\n\n        if (start >= rangeStart && start <= rangeEnd) {\n          // `start` lies within the range that was previously added.\n          if (end > rangeStart && end - 1 <= rangeEnd) {\n            // `end` lies within the range that was previously added as well,\n            // so remove this pair.\n            data.splice(index, 2);\n            index -= 2; // Note: we cannot `return` just yet, as there may still be other\n            // overlapping pairs.\n          } else {\n            // `start` lies within the range that was previously added, but\n            // `end` doesn’t. E.g. `[0, 11, 12, 31]` and we’ve added 5-15, so\n            // now we have `[0, 16, 12, 31]`. This must be written as `[0, 31]`.\n            // Remove the previously added `end` and the current `start`.\n            data.splice(index - 1, 2);\n            index -= 2;\n          } // Note: we cannot return yet.\n\n        }\n      } else if (start == rangeEnd + 1 || start == rangeEnd) {\n        data[index] = rangeStart;\n        return data;\n      } // Check if a new pair must be inserted *before* the current one.\n      else if (start > rangeEnd) {\n          data.splice(index, 0, rangeStart, rangeEnd + 1);\n          return data;\n        } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {\n          // The new range lies entirely within an existing range pair. No action\n          // needed.\n          return data;\n        } else if ( // E.g. `[0, 11]` and you add 5-15 → `[0, 16]`.\n        rangeStart >= start && rangeStart < end || // E.g. `[0, 3]` and you add 3-6 → `[0, 7]`.\n        end == rangeStart) {\n          // Replace `end` with the new value.\n          data[index + 1] = rangeEnd + 1; // Make sure the next range pair doesn’t overlap, e.g. `[0, 11, 12, 14]`\n          // and you add 5-15 → `[0, 16]`, i.e. remove the `12,14` part.\n\n          added = true; // Note: we cannot `return` just yet.\n        } else if (rangeStart <= start && rangeEnd + 1 >= end) {\n          // The new range is a superset of the old range.\n          data[index] = rangeStart;\n          data[index + 1] = rangeEnd + 1;\n          added = true;\n        }\n\n      index += 2;\n    } // The loop has finished without doing anything; add the new pair to the end\n    // of the data set.\n\n\n    if (!added) {\n      data.push(rangeStart, rangeEnd + 1);\n    }\n\n    return data;\n  };\n\n  var dataContains = function (data, codePoint) {\n    var index = 0;\n    var length = data.length; // Exit early if `codePoint` is not within `data`’s overall range.\n\n    var start = data[index];\n    var end = data[length - 1];\n\n    if (length >= 2) {\n      if (codePoint < start || codePoint > end) {\n        return false;\n      }\n    } // Iterate over the data per `(start, end)` pair.\n\n\n    while (index < length) {\n      start = data[index];\n      end = data[index + 1];\n\n      if (codePoint >= start && codePoint < end) {\n        return true;\n      }\n\n      index += 2;\n    }\n\n    return false;\n  };\n\n  var dataIntersection = function (data, codePoints) {\n    var index = 0;\n    var length = codePoints.length;\n    var codePoint;\n    var result = [];\n\n    while (index < length) {\n      codePoint = codePoints[index];\n\n      if (dataContains(data, codePoint)) {\n        result.push(codePoint);\n      }\n\n      ++index;\n    }\n\n    return dataFromCodePoints(result);\n  };\n\n  var dataIsEmpty = function (data) {\n    return !data.length;\n  };\n\n  var dataIsSingleton = function (data) {\n    // Check if the set only represents a single code point.\n    return data.length == 2 && data[0] + 1 == data[1];\n  };\n\n  var dataToArray = function (data) {\n    // Iterate over the data per `(start, end)` pair.\n    var index = 0;\n    var start;\n    var end;\n    var result = [];\n    var length = data.length;\n\n    while (index < length) {\n      start = data[index];\n      end = data[index + 1];\n\n      while (start < end) {\n        result.push(start);\n        ++start;\n      }\n\n      index += 2;\n    }\n\n    return result;\n  };\n  /*--------------------------------------------------------------------------*/\n  // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\n\n  var floor = Math.floor;\n\n  var highSurrogate = function (codePoint) {\n    return parseInt(floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN, 10);\n  };\n\n  var lowSurrogate = function (codePoint) {\n    return parseInt((codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN, 10);\n  };\n\n  var stringFromCharCode = String.fromCharCode;\n\n  var codePointToString = function (codePoint) {\n    var string; // https://mathiasbynens.be/notes/javascript-escapes#single\n    // Note: the `\\b` escape sequence for U+0008 BACKSPACE in strings has a\n    // different meaning in regular expressions (word boundary), so it cannot\n    // be used here.\n\n    if (codePoint == 0x09) {\n      string = '\\\\t';\n    } // Note: IE < 9 treats `'\\v'` as `'v'`, so avoid using it.\n    // else if (codePoint == 0x0B) {\n    // \tstring = '\\\\v';\n    // }\n    else if (codePoint == 0x0A) {\n        string = '\\\\n';\n      } else if (codePoint == 0x0C) {\n        string = '\\\\f';\n      } else if (codePoint == 0x0D) {\n        string = '\\\\r';\n      } else if (codePoint == 0x2D) {\n        // https://mathiasbynens.be/notes/javascript-escapes#hexadecimal\n        // Note: `-` (U+002D HYPHEN-MINUS) is escaped in this way rather\n        // than by backslash-escaping, in case the output is used outside\n        // of a character class in a `u` RegExp. /\\-/u throws, but\n        // /\\x2D/u is fine.\n        string = '\\\\x2D';\n      } else if (codePoint == 0x5C) {\n        string = '\\\\\\\\';\n      } else if (codePoint == 0x24 || codePoint >= 0x28 && codePoint <= 0x2B || codePoint == 0x2E || codePoint == 0x2F || codePoint == 0x3F || codePoint >= 0x5B && codePoint <= 0x5E || codePoint >= 0x7B && codePoint <= 0x7D) {\n        // The code point maps to an unsafe printable ASCII character;\n        // backslash-escape it. Here’s the list of those symbols:\n        //\n        //     $()*+./?[\\]^{|}\n        //\n        // This matches SyntaxCharacters as well as `/` (U+002F SOLIDUS).\n        // https://tc39.github.io/ecma262/#prod-SyntaxCharacter\n        string = '\\\\' + stringFromCharCode(codePoint);\n      } else if (codePoint >= 0x20 && codePoint <= 0x7E) {\n        // The code point maps to one of these printable ASCII symbols\n        // (including the space character):\n        //\n        //      !\"#%&',/0123456789:;<=>@ABCDEFGHIJKLMNO\n        //     PQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz~\n        //\n        // These can safely be used directly.\n        string = stringFromCharCode(codePoint);\n      } else if (codePoint <= 0xFF) {\n        string = '\\\\x' + pad(hex(codePoint), 2);\n      } else {\n        // `codePoint <= 0xFFFF` holds true.\n        // https://mathiasbynens.be/notes/javascript-escapes#unicode\n        string = '\\\\u' + pad(hex(codePoint), 4);\n      } // There’s no need to account for astral symbols / surrogate pairs here,\n    // since `codePointToString` is private and only used for BMP code points.\n    // But if that’s what you need, just add an `else` block with this code:\n    //\n    //     string = '\\\\u' + pad(hex(highSurrogate(codePoint)), 4)\n    //     \t+ '\\\\u' + pad(hex(lowSurrogate(codePoint)), 4);\n\n\n    return string;\n  };\n\n  var codePointToStringUnicode = function (codePoint) {\n    if (codePoint <= 0xFFFF) {\n      return codePointToString(codePoint);\n    }\n\n    return '\\\\u{' + codePoint.toString(16).toUpperCase() + '}';\n  };\n\n  var symbolToCodePoint = function (symbol) {\n    var length = symbol.length;\n    var first = symbol.charCodeAt(0);\n    var second;\n\n    if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1 // There is a next code unit.\n    ) {\n        // `first` is a high surrogate, and there is a next character. Assume\n        // it’s a low surrogate (else it’s invalid usage of Regenerate anyway).\n        second = symbol.charCodeAt(1); // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\n        return (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;\n      }\n\n    return first;\n  };\n\n  var createBMPCharacterClasses = function (data) {\n    // Iterate over the data per `(start, end)` pair.\n    var result = '';\n    var index = 0;\n    var start;\n    var end;\n    var length = data.length;\n\n    if (dataIsSingleton(data)) {\n      return codePointToString(data[0]);\n    }\n\n    while (index < length) {\n      start = data[index];\n      end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.\n\n      if (start == end) {\n        result += codePointToString(start);\n      } else if (start + 1 == end) {\n        result += codePointToString(start) + codePointToString(end);\n      } else {\n        result += codePointToString(start) + '-' + codePointToString(end);\n      }\n\n      index += 2;\n    }\n\n    return '[' + result + ']';\n  };\n\n  var createUnicodeCharacterClasses = function (data) {\n    // Iterate over the data per `(start, end)` pair.\n    var result = '';\n    var index = 0;\n    var start;\n    var end;\n    var length = data.length;\n\n    if (dataIsSingleton(data)) {\n      return codePointToStringUnicode(data[0]);\n    }\n\n    while (index < length) {\n      start = data[index];\n      end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.\n\n      if (start == end) {\n        result += codePointToStringUnicode(start);\n      } else if (start + 1 == end) {\n        result += codePointToStringUnicode(start) + codePointToStringUnicode(end);\n      } else {\n        result += codePointToStringUnicode(start) + '-' + codePointToStringUnicode(end);\n      }\n\n      index += 2;\n    }\n\n    return '[' + result + ']';\n  };\n\n  var splitAtBMP = function (data) {\n    // Iterate over the data per `(start, end)` pair.\n    var loneHighSurrogates = [];\n    var loneLowSurrogates = [];\n    var bmp = [];\n    var astral = [];\n    var index = 0;\n    var start;\n    var end;\n    var length = data.length;\n\n    while (index < length) {\n      start = data[index];\n      end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.\n\n      if (start < HIGH_SURROGATE_MIN) {\n        // The range starts and ends before the high surrogate range.\n        // E.g. (0, 0x10).\n        if (end < HIGH_SURROGATE_MIN) {\n          bmp.push(start, end + 1);\n        } // The range starts before the high surrogate range and ends within it.\n        // E.g. (0, 0xD855).\n\n\n        if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {\n          bmp.push(start, HIGH_SURROGATE_MIN);\n          loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);\n        } // The range starts before the high surrogate range and ends in the low\n        // surrogate range. E.g. (0, 0xDCFF).\n\n\n        if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n          bmp.push(start, HIGH_SURROGATE_MIN);\n          loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);\n          loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);\n        } // The range starts before the high surrogate range and ends after the\n        // low surrogate range. E.g. (0, 0x10FFFF).\n\n\n        if (end > LOW_SURROGATE_MAX) {\n          bmp.push(start, HIGH_SURROGATE_MIN);\n          loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);\n          loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);\n\n          if (end <= 0xFFFF) {\n            bmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n          } else {\n            bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n            astral.push(0xFFFF + 1, end + 1);\n          }\n        }\n      } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {\n        // The range starts and ends in the high surrogate range.\n        // E.g. (0xD855, 0xD866).\n        if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {\n          loneHighSurrogates.push(start, end + 1);\n        } // The range starts in the high surrogate range and ends in the low\n        // surrogate range. E.g. (0xD855, 0xDCFF).\n\n\n        if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n          loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);\n          loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);\n        } // The range starts in the high surrogate range and ends after the low\n        // surrogate range. E.g. (0xD855, 0x10FFFF).\n\n\n        if (end > LOW_SURROGATE_MAX) {\n          loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);\n          loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);\n\n          if (end <= 0xFFFF) {\n            bmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n          } else {\n            bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n            astral.push(0xFFFF + 1, end + 1);\n          }\n        }\n      } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {\n        // The range starts and ends in the low surrogate range.\n        // E.g. (0xDCFF, 0xDDFF).\n        if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n          loneLowSurrogates.push(start, end + 1);\n        } // The range starts in the low surrogate range and ends after the low\n        // surrogate range. E.g. (0xDCFF, 0x10FFFF).\n\n\n        if (end > LOW_SURROGATE_MAX) {\n          loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);\n\n          if (end <= 0xFFFF) {\n            bmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n          } else {\n            bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n            astral.push(0xFFFF + 1, end + 1);\n          }\n        }\n      } else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {\n        // The range starts and ends after the low surrogate range.\n        // E.g. (0xFFAA, 0x10FFFF).\n        if (end <= 0xFFFF) {\n          bmp.push(start, end + 1);\n        } else {\n          bmp.push(start, 0xFFFF + 1);\n          astral.push(0xFFFF + 1, end + 1);\n        }\n      } else {\n        // The range starts and ends in the astral range.\n        astral.push(start, end + 1);\n      }\n\n      index += 2;\n    }\n\n    return {\n      'loneHighSurrogates': loneHighSurrogates,\n      'loneLowSurrogates': loneLowSurrogates,\n      'bmp': bmp,\n      'astral': astral\n    };\n  };\n\n  var optimizeSurrogateMappings = function (surrogateMappings) {\n    var result = [];\n    var tmpLow = [];\n    var addLow = false;\n    var mapping;\n    var nextMapping;\n    var highSurrogates;\n    var lowSurrogates;\n    var nextHighSurrogates;\n    var nextLowSurrogates;\n    var index = -1;\n    var length = surrogateMappings.length;\n\n    while (++index < length) {\n      mapping = surrogateMappings[index];\n      nextMapping = surrogateMappings[index + 1];\n\n      if (!nextMapping) {\n        result.push(mapping);\n        continue;\n      }\n\n      highSurrogates = mapping[0];\n      lowSurrogates = mapping[1];\n      nextHighSurrogates = nextMapping[0];\n      nextLowSurrogates = nextMapping[1]; // Check for identical high surrogate ranges.\n\n      tmpLow = lowSurrogates;\n\n      while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {\n        // Merge with the next item.\n        if (dataIsSingleton(nextLowSurrogates)) {\n          tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);\n        } else {\n          tmpLow = dataAddRange(tmpLow, nextLowSurrogates[0], nextLowSurrogates[1] - 1);\n        }\n\n        ++index;\n        mapping = surrogateMappings[index];\n        highSurrogates = mapping[0];\n        lowSurrogates = mapping[1];\n        nextMapping = surrogateMappings[index + 1];\n        nextHighSurrogates = nextMapping && nextMapping[0];\n        nextLowSurrogates = nextMapping && nextMapping[1];\n        addLow = true;\n      }\n\n      result.push([highSurrogates, addLow ? tmpLow : lowSurrogates]);\n      addLow = false;\n    }\n\n    return optimizeByLowSurrogates(result);\n  };\n\n  var optimizeByLowSurrogates = function (surrogateMappings) {\n    if (surrogateMappings.length == 1) {\n      return surrogateMappings;\n    }\n\n    var index = -1;\n    var innerIndex = -1;\n\n    while (++index < surrogateMappings.length) {\n      var mapping = surrogateMappings[index];\n      var lowSurrogates = mapping[1];\n      var lowSurrogateStart = lowSurrogates[0];\n      var lowSurrogateEnd = lowSurrogates[1];\n      innerIndex = index; // Note: the loop starts at the next index.\n\n      while (++innerIndex < surrogateMappings.length) {\n        var otherMapping = surrogateMappings[innerIndex];\n        var otherLowSurrogates = otherMapping[1];\n        var otherLowSurrogateStart = otherLowSurrogates[0];\n        var otherLowSurrogateEnd = otherLowSurrogates[1];\n\n        if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd && otherLowSurrogates.length === 2) {\n          // Add the code points in the other item to this one.\n          if (dataIsSingleton(otherMapping[0])) {\n            mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);\n          } else {\n            mapping[0] = dataAddRange(mapping[0], otherMapping[0][0], otherMapping[0][1] - 1);\n          } // Remove the other, now redundant, item.\n\n\n          surrogateMappings.splice(innerIndex, 1);\n          --innerIndex;\n        }\n      }\n    }\n\n    return surrogateMappings;\n  };\n\n  var surrogateSet = function (data) {\n    // Exit early if `data` is an empty set.\n    if (!data.length) {\n      return [];\n    } // Iterate over the data per `(start, end)` pair.\n\n\n    var index = 0;\n    var start;\n    var end;\n    var startHigh;\n    var startLow;\n    var endHigh;\n    var endLow;\n    var surrogateMappings = [];\n    var length = data.length;\n\n    while (index < length) {\n      start = data[index];\n      end = data[index + 1] - 1;\n      startHigh = highSurrogate(start);\n      startLow = lowSurrogate(start);\n      endHigh = highSurrogate(end);\n      endLow = lowSurrogate(end);\n      var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;\n      var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;\n      var complete = false; // Append the previous high-surrogate-to-low-surrogate mappings.\n      // Step 1: `(startHigh, startLow)` to `(startHigh, LOW_SURROGATE_MAX)`.\n\n      if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {\n        surrogateMappings.push([[startHigh, endHigh + 1], [startLow, endLow + 1]]);\n        complete = true;\n      } else {\n        surrogateMappings.push([[startHigh, startHigh + 1], [startLow, LOW_SURROGATE_MAX + 1]]);\n      } // Step 2: `(startHigh + 1, LOW_SURROGATE_MIN)` to\n      // `(endHigh - 1, LOW_SURROGATE_MAX)`.\n\n\n      if (!complete && startHigh + 1 < endHigh) {\n        if (endsWithHighestLowSurrogate) {\n          // Combine step 2 and step 3.\n          surrogateMappings.push([[startHigh + 1, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);\n          complete = true;\n        } else {\n          surrogateMappings.push([[startHigh + 1, endHigh], [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]]);\n        }\n      } // Step 3. `(endHigh, LOW_SURROGATE_MIN)` to `(endHigh, endLow)`.\n\n\n      if (!complete) {\n        surrogateMappings.push([[endHigh, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);\n      }\n\n      index += 2;\n    } // The format of `surrogateMappings` is as follows:\n    //\n    //     [ surrogateMapping1, surrogateMapping2 ]\n    //\n    // i.e.:\n    //\n    //     [\n    //       [ highSurrogates1, lowSurrogates1 ],\n    //       [ highSurrogates2, lowSurrogates2 ]\n    //     ]\n\n\n    return optimizeSurrogateMappings(surrogateMappings);\n  };\n\n  var createSurrogateCharacterClasses = function (surrogateMappings) {\n    var result = [];\n    forEach(surrogateMappings, function (surrogateMapping) {\n      var highSurrogates = surrogateMapping[0];\n      var lowSurrogates = surrogateMapping[1];\n      result.push(createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates));\n    });\n    return result.join('|');\n  };\n\n  var createCharacterClassesFromData = function (data, bmpOnly, hasUnicodeFlag) {\n    if (hasUnicodeFlag) {\n      return createUnicodeCharacterClasses(data);\n    }\n\n    var result = [];\n    var parts = splitAtBMP(data);\n    var loneHighSurrogates = parts.loneHighSurrogates;\n    var loneLowSurrogates = parts.loneLowSurrogates;\n    var bmp = parts.bmp;\n    var astral = parts.astral;\n    var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);\n    var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);\n    var surrogateMappings = surrogateSet(astral);\n\n    if (bmpOnly) {\n      bmp = dataAddData(bmp, loneHighSurrogates);\n      hasLoneHighSurrogates = false;\n      bmp = dataAddData(bmp, loneLowSurrogates);\n      hasLoneLowSurrogates = false;\n    }\n\n    if (!dataIsEmpty(bmp)) {\n      // The data set contains BMP code points that are not high surrogates\n      // needed for astral code points in the set.\n      result.push(createBMPCharacterClasses(bmp));\n    }\n\n    if (surrogateMappings.length) {\n      // The data set contains astral code points; append character classes\n      // based on their surrogate pairs.\n      result.push(createSurrogateCharacterClasses(surrogateMappings));\n    } // https://gist.github.com/mathiasbynens/bbe7f870208abcfec860\n\n\n    if (hasLoneHighSurrogates) {\n      result.push(createBMPCharacterClasses(loneHighSurrogates) + // Make sure the high surrogates aren’t part of a surrogate pair.\n      '(?![\\\\uDC00-\\\\uDFFF])');\n    }\n\n    if (hasLoneLowSurrogates) {\n      result.push( // It is not possible to accurately assert the low surrogates aren’t\n      // part of a surrogate pair, since JavaScript regular expressions do\n      // not support lookbehind.\n      '(?:[^\\\\uD800-\\\\uDBFF]|^)' + createBMPCharacterClasses(loneLowSurrogates));\n    }\n\n    return result.join('|');\n  };\n  /*--------------------------------------------------------------------------*/\n  // `regenerate` can be used as a constructor (and new methods can be added to\n  // its prototype) but also as a regular function, the latter of which is the\n  // documented and most common usage. For that reason, it’s not capitalized.\n\n\n  var regenerate = function (value) {\n    if (arguments.length > 1) {\n      value = slice.call(arguments);\n    }\n\n    if (this instanceof regenerate) {\n      this.data = [];\n      return value ? this.add(value) : this;\n    }\n\n    return new regenerate().add(value);\n  };\n\n  regenerate.version = '1.4.2';\n  var proto = regenerate.prototype;\n  extend(proto, {\n    'add': function (value) {\n      var $this = this;\n\n      if (value == null) {\n        return $this;\n      }\n\n      if (value instanceof regenerate) {\n        // Allow passing other Regenerate instances.\n        $this.data = dataAddData($this.data, value.data);\n        return $this;\n      }\n\n      if (arguments.length > 1) {\n        value = slice.call(arguments);\n      }\n\n      if (isArray(value)) {\n        forEach(value, function (item) {\n          $this.add(item);\n        });\n        return $this;\n      }\n\n      $this.data = dataAdd($this.data, isNumber(value) ? value : symbolToCodePoint(value));\n      return $this;\n    },\n    'remove': function (value) {\n      var $this = this;\n\n      if (value == null) {\n        return $this;\n      }\n\n      if (value instanceof regenerate) {\n        // Allow passing other Regenerate instances.\n        $this.data = dataRemoveData($this.data, value.data);\n        return $this;\n      }\n\n      if (arguments.length > 1) {\n        value = slice.call(arguments);\n      }\n\n      if (isArray(value)) {\n        forEach(value, function (item) {\n          $this.remove(item);\n        });\n        return $this;\n      }\n\n      $this.data = dataRemove($this.data, isNumber(value) ? value : symbolToCodePoint(value));\n      return $this;\n    },\n    'addRange': function (start, end) {\n      var $this = this;\n      $this.data = dataAddRange($this.data, isNumber(start) ? start : symbolToCodePoint(start), isNumber(end) ? end : symbolToCodePoint(end));\n      return $this;\n    },\n    'removeRange': function (start, end) {\n      var $this = this;\n      var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);\n      var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);\n      $this.data = dataRemoveRange($this.data, startCodePoint, endCodePoint);\n      return $this;\n    },\n    'intersection': function (argument) {\n      var $this = this; // Allow passing other Regenerate instances.\n      // TODO: Optimize this by writing and using `dataIntersectionData()`.\n\n      var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;\n      $this.data = dataIntersection($this.data, array);\n      return $this;\n    },\n    'contains': function (codePoint) {\n      return dataContains(this.data, isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint));\n    },\n    'clone': function () {\n      var set = new regenerate();\n      set.data = this.data.slice(0);\n      return set;\n    },\n    'toString': function (options) {\n      var result = createCharacterClassesFromData(this.data, options ? options.bmpOnly : false, options ? options.hasUnicodeFlag : false);\n\n      if (!result) {\n        // For an empty set, return something that can be inserted `/here/` to\n        // form a valid regular expression. Avoid `(?:)` since that matches the\n        // empty string.\n        return '[]';\n      } // Use `\\0` instead of `\\x00` where possible.\n\n\n      return result.replace(regexNull, '\\\\0$1');\n    },\n    'toRegExp': function (flags) {\n      var pattern = this.toString(flags && flags.indexOf('u') != -1 ? {\n        'hasUnicodeFlag': true\n      } : null);\n      return RegExp(pattern, flags || '');\n    },\n    'valueOf': function () {\n      // Note: `valueOf` is aliased as `toArray`.\n      return dataToArray(this.data);\n    }\n  });\n  proto.toArray = proto.valueOf; // Some AMD build optimizers, like r.js, check for specific condition patterns\n  // like the following:\n\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    define(function () {\n      return regenerate;\n    });\n  } else if (freeExports && !freeExports.nodeType) {\n    if (freeModule) {\n      // in Node.js, io.js, or RingoJS v0.8.0+\n      freeModule.exports = regenerate;\n    } else {\n      // in Narwhal or RingoJS v0.7.0-\n      freeExports.regenerate = regenerate;\n    }\n  } else {\n    // in Rhino or a web browser\n    root.regenerate = regenerate;\n  }\n})(this);","map":{"version":3,"sources":["/Users/MihirBafna/Downloads/volt-react-dashboard-v1.0.0/node_modules/regenerate/regenerate.js"],"names":["root","freeExports","exports","freeModule","module","freeGlobal","global","window","ERRORS","HIGH_SURROGATE_MIN","HIGH_SURROGATE_MAX","LOW_SURROGATE_MIN","LOW_SURROGATE_MAX","regexNull","object","hasOwnProperty","extend","destination","source","key","call","forEach","array","callback","index","length","toString","isArray","value","isNumber","zeroes","pad","number","totalCharacters","string","String","slice","hex","Number","toUpperCase","dataFromCodePoints","codePoints","max","result","isStart","tmp","previous","push","dataRemove","data","codePoint","start","end","splice","dataRemoveRange","rangeStart","rangeEnd","Error","rangeOrder","dataAdd","lastIndex","RangeError","codePointRange","dataAddData","dataA","dataB","dataAddRange","dataRemoveData","added","dataContains","dataIntersection","dataIsEmpty","dataIsSingleton","dataToArray","floor","Math","highSurrogate","parseInt","lowSurrogate","stringFromCharCode","fromCharCode","codePointToString","codePointToStringUnicode","symbolToCodePoint","symbol","first","charCodeAt","second","createBMPCharacterClasses","createUnicodeCharacterClasses","splitAtBMP","loneHighSurrogates","loneLowSurrogates","bmp","astral","optimizeSurrogateMappings","surrogateMappings","tmpLow","addLow","mapping","nextMapping","highSurrogates","lowSurrogates","nextHighSurrogates","nextLowSurrogates","optimizeByLowSurrogates","innerIndex","lowSurrogateStart","lowSurrogateEnd","otherMapping","otherLowSurrogates","otherLowSurrogateStart","otherLowSurrogateEnd","surrogateSet","startHigh","startLow","endHigh","endLow","startsWithLowestLowSurrogate","endsWithHighestLowSurrogate","complete","createSurrogateCharacterClasses","surrogateMapping","join","createCharacterClassesFromData","bmpOnly","hasUnicodeFlag","parts","hasLoneHighSurrogates","hasLoneLowSurrogates","regenerate","arguments","add","version","proto","prototype","$this","item","remove","startCodePoint","endCodePoint","argument","set","options","replace","flags","pattern","indexOf","RegExp","toArray","valueOf","define","amd","nodeType"],"mappings":"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","sourcesContent":["/*! https://mths.be/regenerate v1.4.2 by @mathias | MIT license */\n;(function(root) {\n\n\t// Detect free variables `exports`.\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`.\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js/io.js or Browserified code,\n\t// and use it as `root`.\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar ERRORS = {\n\t\t'rangeOrder': 'A range\\u2019s `stop` value must be greater than or equal ' +\n\t\t\t'to the `start` value.',\n\t\t'codePointRange': 'Invalid code point value. Code points range from ' +\n\t\t\t'U+000000 to U+10FFFF.'\n\t};\n\n\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-pairs\n\tvar HIGH_SURROGATE_MIN = 0xD800;\n\tvar HIGH_SURROGATE_MAX = 0xDBFF;\n\tvar LOW_SURROGATE_MIN = 0xDC00;\n\tvar LOW_SURROGATE_MAX = 0xDFFF;\n\n\t// In Regenerate output, `\\0` is never preceded by `\\` because we sort by\n\t// code point value, so let’s keep this regular expression simple.\n\tvar regexNull = /\\\\x00([^0123456789]|$)/g;\n\n\tvar object = {};\n\tvar hasOwnProperty = object.hasOwnProperty;\n\tvar extend = function(destination, source) {\n\t\tvar key;\n\t\tfor (key in source) {\n\t\t\tif (hasOwnProperty.call(source, key)) {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t}\n\t\treturn destination;\n\t};\n\n\tvar forEach = function(array, callback) {\n\t\tvar index = -1;\n\t\tvar length = array.length;\n\t\twhile (++index < length) {\n\t\t\tcallback(array[index], index);\n\t\t}\n\t};\n\n\tvar toString = object.toString;\n\tvar isArray = function(value) {\n\t\treturn toString.call(value) == '[object Array]';\n\t};\n\tvar isNumber = function(value) {\n\t\treturn typeof value == 'number' ||\n\t\t\ttoString.call(value) == '[object Number]';\n\t};\n\n\t// This assumes that `number` is a positive integer that `toString()`s nicely\n\t// (which is the case for all code point values).\n\tvar zeroes = '0000';\n\tvar pad = function(number, totalCharacters) {\n\t\tvar string = String(number);\n\t\treturn string.length < totalCharacters\n\t\t\t? (zeroes + string).slice(-totalCharacters)\n\t\t\t: string;\n\t};\n\n\tvar hex = function(number) {\n\t\treturn Number(number).toString(16).toUpperCase();\n\t};\n\n\tvar slice = [].slice;\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar dataFromCodePoints = function(codePoints) {\n\t\tvar index = -1;\n\t\tvar length = codePoints.length;\n\t\tvar max = length - 1;\n\t\tvar result = [];\n\t\tvar isStart = true;\n\t\tvar tmp;\n\t\tvar previous = 0;\n\t\twhile (++index < length) {\n\t\t\ttmp = codePoints[index];\n\t\t\tif (isStart) {\n\t\t\t\tresult.push(tmp);\n\t\t\t\tprevious = tmp;\n\t\t\t\tisStart = false;\n\t\t\t} else {\n\t\t\t\tif (tmp == previous + 1) {\n\t\t\t\t\tif (index != max) {\n\t\t\t\t\t\tprevious = tmp;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisStart = true;\n\t\t\t\t\t\tresult.push(tmp + 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// End the previous range and start a new one.\n\t\t\t\t\tresult.push(previous + 1, tmp);\n\t\t\t\t\tprevious = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!isStart) {\n\t\t\tresult.push(tmp + 1);\n\t\t}\n\t\treturn result;\n\t};\n\n\tvar dataRemove = function(data, codePoint) {\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\tvar index = 0;\n\t\tvar start;\n\t\tvar end;\n\t\tvar length = data.length;\n\t\twhile (index < length) {\n\t\t\tstart = data[index];\n\t\t\tend = data[index + 1];\n\t\t\tif (codePoint >= start && codePoint < end) {\n\t\t\t\t// Modify this pair.\n\t\t\t\tif (codePoint == start) {\n\t\t\t\t\tif (end == start + 1) {\n\t\t\t\t\t\t// Just remove `start` and `end`.\n\t\t\t\t\t\tdata.splice(index, 2);\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Just replace `start` with a new value.\n\t\t\t\t\t\tdata[index] = codePoint + 1;\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\t\t\t\t} else if (codePoint == end - 1) {\n\t\t\t\t\t// Just replace `end` with a new value.\n\t\t\t\t\tdata[index + 1] = codePoint;\n\t\t\t\t\treturn data;\n\t\t\t\t} else {\n\t\t\t\t\t// Replace `[start, end]` with `[startA, endA, startB, endB]`.\n\t\t\t\t\tdata.splice(index, 2, start, codePoint, codePoint + 1, end);\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindex += 2;\n\t\t}\n\t\treturn data;\n\t};\n\n\tvar dataRemoveRange = function(data, rangeStart, rangeEnd) {\n\t\tif (rangeEnd < rangeStart) {\n\t\t\tthrow Error(ERRORS.rangeOrder);\n\t\t}\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\tvar index = 0;\n\t\tvar start;\n\t\tvar end;\n\t\twhile (index < data.length) {\n\t\t\tstart = data[index];\n\t\t\tend = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.\n\n\t\t\t// Exit as soon as no more matching pairs can be found.\n\t\t\tif (start > rangeEnd) {\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t// Check if this range pair is equal to, or forms a subset of, the range\n\t\t\t// to be removed.\n\t\t\t// E.g. we have `[0, 11, 40, 51]` and want to remove 0-10 → `[40, 51]`.\n\t\t\t// E.g. we have `[40, 51]` and want to remove 0-100 → `[]`.\n\t\t\tif (rangeStart <= start && rangeEnd >= end) {\n\t\t\t\t// Remove this pair.\n\t\t\t\tdata.splice(index, 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if both `rangeStart` and `rangeEnd` are within the bounds of\n\t\t\t// this pair.\n\t\t\t// E.g. we have `[0, 11]` and want to remove 4-6 → `[0, 4, 7, 11]`.\n\t\t\tif (rangeStart >= start && rangeEnd < end) {\n\t\t\t\tif (rangeStart == start) {\n\t\t\t\t\t// Replace `[start, end]` with `[startB, endB]`.\n\t\t\t\t\tdata[index] = rangeEnd + 1;\n\t\t\t\t\tdata[index + 1] = end + 1;\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\t\t\t\t// Replace `[start, end]` with `[startA, endA, startB, endB]`.\n\t\t\t\tdata.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t// Check if only `rangeStart` is within the bounds of this pair.\n\t\t\t// E.g. we have `[0, 11]` and want to remove 4-20 → `[0, 4]`.\n\t\t\tif (rangeStart >= start && rangeStart <= end) {\n\t\t\t\t// Replace `end` with `rangeStart`.\n\t\t\t\tdata[index + 1] = rangeStart;\n\t\t\t\t// Note: we cannot `return` just yet, in case any following pairs still\n\t\t\t\t// contain matching code points.\n\t\t\t\t// E.g. we have `[0, 11, 14, 31]` and want to remove 4-20\n\t\t\t\t// → `[0, 4, 21, 31]`.\n\t\t\t}\n\n\t\t\t// Check if only `rangeEnd` is within the bounds of this pair.\n\t\t\t// E.g. we have `[14, 31]` and want to remove 4-20 → `[21, 31]`.\n\t\t\telse if (rangeEnd >= start && rangeEnd <= end) {\n\t\t\t\t// Just replace `start`.\n\t\t\t\tdata[index] = rangeEnd + 1;\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tindex += 2;\n\t\t}\n\t\treturn data;\n\t};\n\n\t var dataAdd = function(data, codePoint) {\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\tvar index = 0;\n\t\tvar start;\n\t\tvar end;\n\t\tvar lastIndex = null;\n\t\tvar length = data.length;\n\t\tif (codePoint < 0x0 || codePoint > 0x10FFFF) {\n\t\t\tthrow RangeError(ERRORS.codePointRange);\n\t\t}\n\t\twhile (index < length) {\n\t\t\tstart = data[index];\n\t\t\tend = data[index + 1];\n\n\t\t\t// Check if the code point is already in the set.\n\t\t\tif (codePoint >= start && codePoint < end) {\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tif (codePoint == start - 1) {\n\t\t\t\t// Just replace `start` with a new value.\n\t\t\t\tdata[index] = codePoint;\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t// At this point, if `start` is `greater` than `codePoint`, insert a new\n\t\t\t// `[start, end]` pair before the current pair, or after the current pair\n\t\t\t// if there is a known `lastIndex`.\n\t\t\tif (start > codePoint) {\n\t\t\t\tdata.splice(\n\t\t\t\t\tlastIndex != null ? lastIndex + 2 : 0,\n\t\t\t\t\t0,\n\t\t\t\t\tcodePoint,\n\t\t\t\t\tcodePoint + 1\n\t\t\t\t);\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tif (codePoint == end) {\n\t\t\t\t// Check if adding this code point causes two separate ranges to become\n\t\t\t\t// a single range, e.g. `dataAdd([0, 4, 5, 10], 4)` → `[0, 10]`.\n\t\t\t\tif (codePoint + 1 == data[index + 2]) {\n\t\t\t\t\tdata.splice(index, 4, start, data[index + 3]);\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\t\t\t\t// Else, just replace `end` with a new value.\n\t\t\t\tdata[index + 1] = codePoint + 1;\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\tlastIndex = index;\n\t\t\tindex += 2;\n\t\t}\n\t\t// The loop has finished; add the new pair to the end of the data set.\n\t\tdata.push(codePoint, codePoint + 1);\n\t\treturn data;\n\t};\n\n\tvar dataAddData = function(dataA, dataB) {\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\tvar index = 0;\n\t\tvar start;\n\t\tvar end;\n\t\tvar data = dataA.slice();\n\t\tvar length = dataB.length;\n\t\twhile (index < length) {\n\t\t\tstart = dataB[index];\n\t\t\tend = dataB[index + 1] - 1;\n\t\t\tif (start == end) {\n\t\t\t\tdata = dataAdd(data, start);\n\t\t\t} else {\n\t\t\t\tdata = dataAddRange(data, start, end);\n\t\t\t}\n\t\t\tindex += 2;\n\t\t}\n\t\treturn data;\n\t};\n\n\tvar dataRemoveData = function(dataA, dataB) {\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\tvar index = 0;\n\t\tvar start;\n\t\tvar end;\n\t\tvar data = dataA.slice();\n\t\tvar length = dataB.length;\n\t\twhile (index < length) {\n\t\t\tstart = dataB[index];\n\t\t\tend = dataB[index + 1] - 1;\n\t\t\tif (start == end) {\n\t\t\t\tdata = dataRemove(data, start);\n\t\t\t} else {\n\t\t\t\tdata = dataRemoveRange(data, start, end);\n\t\t\t}\n\t\t\tindex += 2;\n\t\t}\n\t\treturn data;\n\t};\n\n\tvar dataAddRange = function(data, rangeStart, rangeEnd) {\n\t\tif (rangeEnd < rangeStart) {\n\t\t\tthrow Error(ERRORS.rangeOrder);\n\t\t}\n\t\tif (\n\t\t\trangeStart < 0x0 || rangeStart > 0x10FFFF ||\n\t\t\trangeEnd < 0x0 || rangeEnd > 0x10FFFF\n\t\t) {\n\t\t\tthrow RangeError(ERRORS.codePointRange);\n\t\t}\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\tvar index = 0;\n\t\tvar start;\n\t\tvar end;\n\t\tvar added = false;\n\t\tvar length = data.length;\n\t\twhile (index < length) {\n\t\t\tstart = data[index];\n\t\t\tend = data[index + 1];\n\n\t\t\tif (added) {\n\t\t\t\t// The range has already been added to the set; at this point, we just\n\t\t\t\t// need to get rid of the following ranges in case they overlap.\n\n\t\t\t\t// Check if this range can be combined with the previous range.\n\t\t\t\tif (start == rangeEnd + 1) {\n\t\t\t\t\tdata.splice(index - 1, 2);\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Exit as soon as no more possibly overlapping pairs can be found.\n\t\t\t\tif (start > rangeEnd) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// E.g. `[0, 11, 12, 16]` and we’ve added 5-15, so we now have\n\t\t\t\t// `[0, 16, 12, 16]`. Remove the `12,16` part, as it lies within the\n\t\t\t\t// `0,16` range that was previously added.\n\t\t\t\tif (start >= rangeStart && start <= rangeEnd) {\n\t\t\t\t\t// `start` lies within the range that was previously added.\n\n\t\t\t\t\tif (end > rangeStart && end - 1 <= rangeEnd) {\n\t\t\t\t\t\t// `end` lies within the range that was previously added as well,\n\t\t\t\t\t\t// so remove this pair.\n\t\t\t\t\t\tdata.splice(index, 2);\n\t\t\t\t\t\tindex -= 2;\n\t\t\t\t\t\t// Note: we cannot `return` just yet, as there may still be other\n\t\t\t\t\t\t// overlapping pairs.\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// `start` lies within the range that was previously added, but\n\t\t\t\t\t\t// `end` doesn’t. E.g. `[0, 11, 12, 31]` and we’ve added 5-15, so\n\t\t\t\t\t\t// now we have `[0, 16, 12, 31]`. This must be written as `[0, 31]`.\n\t\t\t\t\t\t// Remove the previously added `end` and the current `start`.\n\t\t\t\t\t\tdata.splice(index - 1, 2);\n\t\t\t\t\t\tindex -= 2;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: we cannot return yet.\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\telse if (start == rangeEnd + 1 || start == rangeEnd) {\n\t\t\t\tdata[index] = rangeStart;\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t// Check if a new pair must be inserted *before* the current one.\n\t\t\telse if (start > rangeEnd) {\n\t\t\t\tdata.splice(index, 0, rangeStart, rangeEnd + 1);\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\telse if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {\n\t\t\t\t// The new range lies entirely within an existing range pair. No action\n\t\t\t\t// needed.\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\telse if (\n\t\t\t\t// E.g. `[0, 11]` and you add 5-15 → `[0, 16]`.\n\t\t\t\t(rangeStart >= start && rangeStart < end) ||\n\t\t\t\t// E.g. `[0, 3]` and you add 3-6 → `[0, 7]`.\n\t\t\t\tend == rangeStart\n\t\t\t) {\n\t\t\t\t// Replace `end` with the new value.\n\t\t\t\tdata[index + 1] = rangeEnd + 1;\n\t\t\t\t// Make sure the next range pair doesn’t overlap, e.g. `[0, 11, 12, 14]`\n\t\t\t\t// and you add 5-15 → `[0, 16]`, i.e. remove the `12,14` part.\n\t\t\t\tadded = true;\n\t\t\t\t// Note: we cannot `return` just yet.\n\t\t\t}\n\n\t\t\telse if (rangeStart <= start && rangeEnd + 1 >= end) {\n\t\t\t\t// The new range is a superset of the old range.\n\t\t\t\tdata[index] = rangeStart;\n\t\t\t\tdata[index + 1] = rangeEnd + 1;\n\t\t\t\tadded = true;\n\t\t\t}\n\n\t\t\tindex += 2;\n\t\t}\n\t\t// The loop has finished without doing anything; add the new pair to the end\n\t\t// of the data set.\n\t\tif (!added) {\n\t\t\tdata.push(rangeStart, rangeEnd + 1);\n\t\t}\n\t\treturn data;\n\t};\n\n\tvar dataContains = function(data, codePoint) {\n\t\tvar index = 0;\n\t\tvar length = data.length;\n\t\t// Exit early if `codePoint` is not within `data`’s overall range.\n\t\tvar start = data[index];\n\t\tvar end = data[length - 1];\n\t\tif (length >= 2) {\n\t\t\tif (codePoint < start || codePoint > end) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\twhile (index < length) {\n\t\t\tstart = data[index];\n\t\t\tend = data[index + 1];\n\t\t\tif (codePoint >= start && codePoint < end) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tindex += 2;\n\t\t}\n\t\treturn false;\n\t};\n\n\tvar dataIntersection = function(data, codePoints) {\n\t\tvar index = 0;\n\t\tvar length = codePoints.length;\n\t\tvar codePoint;\n\t\tvar result = [];\n\t\twhile (index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tif (dataContains(data, codePoint)) {\n\t\t\t\tresult.push(codePoint);\n\t\t\t}\n\t\t\t++index;\n\t\t}\n\t\treturn dataFromCodePoints(result);\n\t};\n\n\tvar dataIsEmpty = function(data) {\n\t\treturn !data.length;\n\t};\n\n\tvar dataIsSingleton = function(data) {\n\t\t// Check if the set only represents a single code point.\n\t\treturn data.length == 2 && data[0] + 1 == data[1];\n\t};\n\n\tvar dataToArray = function(data) {\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\tvar index = 0;\n\t\tvar start;\n\t\tvar end;\n\t\tvar result = [];\n\t\tvar length = data.length;\n\t\twhile (index < length) {\n\t\t\tstart = data[index];\n\t\t\tend = data[index + 1];\n\t\t\twhile (start < end) {\n\t\t\t\tresult.push(start);\n\t\t\t\t++start;\n\t\t\t}\n\t\t\tindex += 2;\n\t\t}\n\t\treturn result;\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\tvar floor = Math.floor;\n\tvar highSurrogate = function(codePoint) {\n\t\treturn parseInt(\n\t\t\tfloor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN,\n\t\t\t10\n\t\t);\n\t};\n\n\tvar lowSurrogate = function(codePoint) {\n\t\treturn parseInt(\n\t\t\t(codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN,\n\t\t\t10\n\t\t);\n\t};\n\n\tvar stringFromCharCode = String.fromCharCode;\n\tvar codePointToString = function(codePoint) {\n\t\tvar string;\n\t\t// https://mathiasbynens.be/notes/javascript-escapes#single\n\t\t// Note: the `\\b` escape sequence for U+0008 BACKSPACE in strings has a\n\t\t// different meaning in regular expressions (word boundary), so it cannot\n\t\t// be used here.\n\t\tif (codePoint == 0x09) {\n\t\t\tstring = '\\\\t';\n\t\t}\n\t\t// Note: IE < 9 treats `'\\v'` as `'v'`, so avoid using it.\n\t\t// else if (codePoint == 0x0B) {\n\t\t// \tstring = '\\\\v';\n\t\t// }\n\t\telse if (codePoint == 0x0A) {\n\t\t\tstring = '\\\\n';\n\t\t}\n\t\telse if (codePoint == 0x0C) {\n\t\t\tstring = '\\\\f';\n\t\t}\n\t\telse if (codePoint == 0x0D) {\n\t\t\tstring = '\\\\r';\n\t\t}\n\t\telse if (codePoint == 0x2D) {\n\t\t\t// https://mathiasbynens.be/notes/javascript-escapes#hexadecimal\n\t\t\t// Note: `-` (U+002D HYPHEN-MINUS) is escaped in this way rather\n\t\t\t// than by backslash-escaping, in case the output is used outside\n\t\t\t// of a character class in a `u` RegExp. /\\-/u throws, but\n\t\t\t// /\\x2D/u is fine.\n\t\t\tstring = '\\\\x2D';\n\t\t}\n\t\telse if (codePoint == 0x5C) {\n\t\t\tstring = '\\\\\\\\';\n\t\t}\n\t\telse if (\n\t\t\tcodePoint == 0x24 ||\n\t\t\t(codePoint >= 0x28 && codePoint <= 0x2B) ||\n\t\t\tcodePoint == 0x2E || codePoint == 0x2F ||\n\t\t\tcodePoint == 0x3F ||\n\t\t\t(codePoint >= 0x5B && codePoint <= 0x5E) ||\n\t\t\t(codePoint >= 0x7B && codePoint <= 0x7D)\n\t\t) {\n\t\t\t// The code point maps to an unsafe printable ASCII character;\n\t\t\t// backslash-escape it. Here’s the list of those symbols:\n\t\t\t//\n\t\t\t//     $()*+./?[\\]^{|}\n\t\t\t//\n\t\t\t// This matches SyntaxCharacters as well as `/` (U+002F SOLIDUS).\n\t\t\t// https://tc39.github.io/ecma262/#prod-SyntaxCharacter\n\t\t\tstring = '\\\\' + stringFromCharCode(codePoint);\n\t\t}\n\t\telse if (codePoint >= 0x20 && codePoint <= 0x7E) {\n\t\t\t// The code point maps to one of these printable ASCII symbols\n\t\t\t// (including the space character):\n\t\t\t//\n\t\t\t//      !\"#%&',/0123456789:;<=>@ABCDEFGHIJKLMNO\n\t\t\t//     PQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz~\n\t\t\t//\n\t\t\t// These can safely be used directly.\n\t\t\tstring = stringFromCharCode(codePoint);\n\t\t}\n\t\telse if (codePoint <= 0xFF) {\n\t\t\tstring = '\\\\x' + pad(hex(codePoint), 2);\n\t\t}\n\t\telse { // `codePoint <= 0xFFFF` holds true.\n\t\t\t// https://mathiasbynens.be/notes/javascript-escapes#unicode\n\t\t\tstring = '\\\\u' + pad(hex(codePoint), 4);\n\t\t}\n\n\t\t// There’s no need to account for astral symbols / surrogate pairs here,\n\t\t// since `codePointToString` is private and only used for BMP code points.\n\t\t// But if that’s what you need, just add an `else` block with this code:\n\t\t//\n\t\t//     string = '\\\\u' + pad(hex(highSurrogate(codePoint)), 4)\n\t\t//     \t+ '\\\\u' + pad(hex(lowSurrogate(codePoint)), 4);\n\n\t\treturn string;\n\t};\n\n\tvar codePointToStringUnicode = function(codePoint) {\n\t\tif (codePoint <= 0xFFFF) {\n\t\t\treturn codePointToString(codePoint);\n\t\t}\n\t\treturn '\\\\u{' + codePoint.toString(16).toUpperCase() + '}';\n\t};\n\n\tvar symbolToCodePoint = function(symbol) {\n\t\tvar length = symbol.length;\n\t\tvar first = symbol.charCodeAt(0);\n\t\tvar second;\n\t\tif (\n\t\t\tfirst >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX &&\n\t\t\tlength > 1 // There is a next code unit.\n\t\t) {\n\t\t\t// `first` is a high surrogate, and there is a next character. Assume\n\t\t\t// it’s a low surrogate (else it’s invalid usage of Regenerate anyway).\n\t\t\tsecond = symbol.charCodeAt(1);\n\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\treturn (first - HIGH_SURROGATE_MIN) * 0x400 +\n\t\t\t\tsecond - LOW_SURROGATE_MIN + 0x10000;\n\t\t}\n\t\treturn first;\n\t};\n\n\tvar createBMPCharacterClasses = function(data) {\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\tvar result = '';\n\t\tvar index = 0;\n\t\tvar start;\n\t\tvar end;\n\t\tvar length = data.length;\n\t\tif (dataIsSingleton(data)) {\n\t\t\treturn codePointToString(data[0]);\n\t\t}\n\t\twhile (index < length) {\n\t\t\tstart = data[index];\n\t\t\tend = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.\n\t\t\tif (start == end) {\n\t\t\t\tresult += codePointToString(start);\n\t\t\t} else if (start + 1 == end) {\n\t\t\t\tresult += codePointToString(start) + codePointToString(end);\n\t\t\t} else {\n\t\t\t\tresult += codePointToString(start) + '-' + codePointToString(end);\n\t\t\t}\n\t\t\tindex += 2;\n\t\t}\n\t\treturn '[' + result + ']';\n\t};\n\n\tvar createUnicodeCharacterClasses = function(data) {\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\tvar result = '';\n\t\tvar index = 0;\n\t\tvar start;\n\t\tvar end;\n\t\tvar length = data.length;\n\t\tif (dataIsSingleton(data)) {\n\t\t\treturn codePointToStringUnicode(data[0]);\n\t\t}\n\t\twhile (index < length) {\n\t\t\tstart = data[index];\n\t\t\tend = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.\n\t\t\tif (start == end) {\n\t\t\t\tresult += codePointToStringUnicode(start);\n\t\t\t} else if (start + 1 == end) {\n\t\t\t\tresult += codePointToStringUnicode(start) + codePointToStringUnicode(end);\n\t\t\t} else {\n\t\t\t\tresult += codePointToStringUnicode(start) + '-' + codePointToStringUnicode(end);\n\t\t\t}\n\t\t\tindex += 2;\n\t\t}\n\t\treturn '[' + result + ']';\n\t};\n\n\tvar splitAtBMP = function(data) {\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\tvar loneHighSurrogates = [];\n\t\tvar loneLowSurrogates = [];\n\t\tvar bmp = [];\n\t\tvar astral = [];\n\t\tvar index = 0;\n\t\tvar start;\n\t\tvar end;\n\t\tvar length = data.length;\n\t\twhile (index < length) {\n\t\t\tstart = data[index];\n\t\t\tend = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.\n\n\t\t\tif (start < HIGH_SURROGATE_MIN) {\n\n\t\t\t\t// The range starts and ends before the high surrogate range.\n\t\t\t\t// E.g. (0, 0x10).\n\t\t\t\tif (end < HIGH_SURROGATE_MIN) {\n\t\t\t\t\tbmp.push(start, end + 1);\n\t\t\t\t}\n\n\t\t\t\t// The range starts before the high surrogate range and ends within it.\n\t\t\t\t// E.g. (0, 0xD855).\n\t\t\t\tif (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {\n\t\t\t\t\tbmp.push(start, HIGH_SURROGATE_MIN);\n\t\t\t\t\tloneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);\n\t\t\t\t}\n\n\t\t\t\t// The range starts before the high surrogate range and ends in the low\n\t\t\t\t// surrogate range. E.g. (0, 0xDCFF).\n\t\t\t\tif (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n\t\t\t\t\tbmp.push(start, HIGH_SURROGATE_MIN);\n\t\t\t\t\tloneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);\n\t\t\t\t\tloneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);\n\t\t\t\t}\n\n\t\t\t\t// The range starts before the high surrogate range and ends after the\n\t\t\t\t// low surrogate range. E.g. (0, 0x10FFFF).\n\t\t\t\tif (end > LOW_SURROGATE_MAX) {\n\t\t\t\t\tbmp.push(start, HIGH_SURROGATE_MIN);\n\t\t\t\t\tloneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);\n\t\t\t\t\tloneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);\n\t\t\t\t\tif (end <= 0xFFFF) {\n\t\t\t\t\t\tbmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n\t\t\t\t\t\tastral.push(0xFFFF + 1, end + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {\n\n\t\t\t\t// The range starts and ends in the high surrogate range.\n\t\t\t\t// E.g. (0xD855, 0xD866).\n\t\t\t\tif (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {\n\t\t\t\t\tloneHighSurrogates.push(start, end + 1);\n\t\t\t\t}\n\n\t\t\t\t// The range starts in the high surrogate range and ends in the low\n\t\t\t\t// surrogate range. E.g. (0xD855, 0xDCFF).\n\t\t\t\tif (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n\t\t\t\t\tloneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);\n\t\t\t\t\tloneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);\n\t\t\t\t}\n\n\t\t\t\t// The range starts in the high surrogate range and ends after the low\n\t\t\t\t// surrogate range. E.g. (0xD855, 0x10FFFF).\n\t\t\t\tif (end > LOW_SURROGATE_MAX) {\n\t\t\t\t\tloneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);\n\t\t\t\t\tloneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);\n\t\t\t\t\tif (end <= 0xFFFF) {\n\t\t\t\t\t\tbmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n\t\t\t\t\t\tastral.push(0xFFFF + 1, end + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {\n\n\t\t\t\t// The range starts and ends in the low surrogate range.\n\t\t\t\t// E.g. (0xDCFF, 0xDDFF).\n\t\t\t\tif (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n\t\t\t\t\tloneLowSurrogates.push(start, end + 1);\n\t\t\t\t}\n\n\t\t\t\t// The range starts in the low surrogate range and ends after the low\n\t\t\t\t// surrogate range. E.g. (0xDCFF, 0x10FFFF).\n\t\t\t\tif (end > LOW_SURROGATE_MAX) {\n\t\t\t\t\tloneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);\n\t\t\t\t\tif (end <= 0xFFFF) {\n\t\t\t\t\t\tbmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n\t\t\t\t\t\tastral.push(0xFFFF + 1, end + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {\n\n\t\t\t\t// The range starts and ends after the low surrogate range.\n\t\t\t\t// E.g. (0xFFAA, 0x10FFFF).\n\t\t\t\tif (end <= 0xFFFF) {\n\t\t\t\t\tbmp.push(start, end + 1);\n\t\t\t\t} else {\n\t\t\t\t\tbmp.push(start, 0xFFFF + 1);\n\t\t\t\t\tastral.push(0xFFFF + 1, end + 1);\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The range starts and ends in the astral range.\n\t\t\t\tastral.push(start, end + 1);\n\n\t\t\t}\n\n\t\t\tindex += 2;\n\t\t}\n\t\treturn {\n\t\t\t'loneHighSurrogates': loneHighSurrogates,\n\t\t\t'loneLowSurrogates': loneLowSurrogates,\n\t\t\t'bmp': bmp,\n\t\t\t'astral': astral\n\t\t};\n\t};\n\n\tvar optimizeSurrogateMappings = function(surrogateMappings) {\n\t\tvar result = [];\n\t\tvar tmpLow = [];\n\t\tvar addLow = false;\n\t\tvar mapping;\n\t\tvar nextMapping;\n\t\tvar highSurrogates;\n\t\tvar lowSurrogates;\n\t\tvar nextHighSurrogates;\n\t\tvar nextLowSurrogates;\n\t\tvar index = -1;\n\t\tvar length = surrogateMappings.length;\n\t\twhile (++index < length) {\n\t\t\tmapping = surrogateMappings[index];\n\t\t\tnextMapping = surrogateMappings[index + 1];\n\t\t\tif (!nextMapping) {\n\t\t\t\tresult.push(mapping);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thighSurrogates = mapping[0];\n\t\t\tlowSurrogates = mapping[1];\n\t\t\tnextHighSurrogates = nextMapping[0];\n\t\t\tnextLowSurrogates = nextMapping[1];\n\n\t\t\t// Check for identical high surrogate ranges.\n\t\t\ttmpLow = lowSurrogates;\n\t\t\twhile (\n\t\t\t\tnextHighSurrogates &&\n\t\t\t\thighSurrogates[0] == nextHighSurrogates[0] &&\n\t\t\t\thighSurrogates[1] == nextHighSurrogates[1]\n\t\t\t) {\n\t\t\t\t// Merge with the next item.\n\t\t\t\tif (dataIsSingleton(nextLowSurrogates)) {\n\t\t\t\t\ttmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);\n\t\t\t\t} else {\n\t\t\t\t\ttmpLow = dataAddRange(\n\t\t\t\t\t\ttmpLow,\n\t\t\t\t\t\tnextLowSurrogates[0],\n\t\t\t\t\t\tnextLowSurrogates[1] - 1\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t++index;\n\t\t\t\tmapping = surrogateMappings[index];\n\t\t\t\thighSurrogates = mapping[0];\n\t\t\t\tlowSurrogates = mapping[1];\n\t\t\t\tnextMapping = surrogateMappings[index + 1];\n\t\t\t\tnextHighSurrogates = nextMapping && nextMapping[0];\n\t\t\t\tnextLowSurrogates = nextMapping && nextMapping[1];\n\t\t\t\taddLow = true;\n\t\t\t}\n\t\t\tresult.push([\n\t\t\t\thighSurrogates,\n\t\t\t\taddLow ? tmpLow : lowSurrogates\n\t\t\t]);\n\t\t\taddLow = false;\n\t\t}\n\t\treturn optimizeByLowSurrogates(result);\n\t};\n\n\tvar optimizeByLowSurrogates = function(surrogateMappings) {\n\t\tif (surrogateMappings.length == 1) {\n\t\t\treturn surrogateMappings;\n\t\t}\n\t\tvar index = -1;\n\t\tvar innerIndex = -1;\n\t\twhile (++index < surrogateMappings.length) {\n\t\t\tvar mapping = surrogateMappings[index];\n\t\t\tvar lowSurrogates = mapping[1];\n\t\t\tvar lowSurrogateStart = lowSurrogates[0];\n\t\t\tvar lowSurrogateEnd = lowSurrogates[1];\n\t\t\tinnerIndex = index; // Note: the loop starts at the next index.\n\t\t\twhile (++innerIndex < surrogateMappings.length) {\n\t\t\t\tvar otherMapping = surrogateMappings[innerIndex];\n\t\t\t\tvar otherLowSurrogates = otherMapping[1];\n\t\t\t\tvar otherLowSurrogateStart = otherLowSurrogates[0];\n\t\t\t\tvar otherLowSurrogateEnd = otherLowSurrogates[1];\n\t\t\t\tif (\n\t\t\t\t\tlowSurrogateStart == otherLowSurrogateStart &&\n\t\t\t\t\tlowSurrogateEnd == otherLowSurrogateEnd &&\n\t\t\t\t\totherLowSurrogates.length === 2\n\t\t\t\t) {\n\t\t\t\t\t// Add the code points in the other item to this one.\n\t\t\t\t\tif (dataIsSingleton(otherMapping[0])) {\n\t\t\t\t\t\tmapping[0] = dataAdd(mapping[0], otherMapping[0][0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmapping[0] = dataAddRange(\n\t\t\t\t\t\t\tmapping[0],\n\t\t\t\t\t\t\totherMapping[0][0],\n\t\t\t\t\t\t\totherMapping[0][1] - 1\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// Remove the other, now redundant, item.\n\t\t\t\t\tsurrogateMappings.splice(innerIndex, 1);\n\t\t\t\t\t--innerIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn surrogateMappings;\n\t};\n\n\tvar surrogateSet = function(data) {\n\t\t// Exit early if `data` is an empty set.\n\t\tif (!data.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Iterate over the data per `(start, end)` pair.\n\t\tvar index = 0;\n\t\tvar start;\n\t\tvar end;\n\t\tvar startHigh;\n\t\tvar startLow;\n\t\tvar endHigh;\n\t\tvar endLow;\n\t\tvar surrogateMappings = [];\n\t\tvar length = data.length;\n\t\twhile (index < length) {\n\t\t\tstart = data[index];\n\t\t\tend = data[index + 1] - 1;\n\n\t\t\tstartHigh = highSurrogate(start);\n\t\t\tstartLow = lowSurrogate(start);\n\t\t\tendHigh = highSurrogate(end);\n\t\t\tendLow = lowSurrogate(end);\n\n\t\t\tvar startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;\n\t\t\tvar endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;\n\t\t\tvar complete = false;\n\n\t\t\t// Append the previous high-surrogate-to-low-surrogate mappings.\n\t\t\t// Step 1: `(startHigh, startLow)` to `(startHigh, LOW_SURROGATE_MAX)`.\n\t\t\tif (\n\t\t\t\tstartHigh == endHigh ||\n\t\t\t\tstartsWithLowestLowSurrogate && endsWithHighestLowSurrogate\n\t\t\t) {\n\t\t\t\tsurrogateMappings.push([\n\t\t\t\t\t[startHigh, endHigh + 1],\n\t\t\t\t\t[startLow, endLow + 1]\n\t\t\t\t]);\n\t\t\t\tcomplete = true;\n\t\t\t} else {\n\t\t\t\tsurrogateMappings.push([\n\t\t\t\t\t[startHigh, startHigh + 1],\n\t\t\t\t\t[startLow, LOW_SURROGATE_MAX + 1]\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t// Step 2: `(startHigh + 1, LOW_SURROGATE_MIN)` to\n\t\t\t// `(endHigh - 1, LOW_SURROGATE_MAX)`.\n\t\t\tif (!complete && startHigh + 1 < endHigh) {\n\t\t\t\tif (endsWithHighestLowSurrogate) {\n\t\t\t\t\t// Combine step 2 and step 3.\n\t\t\t\t\tsurrogateMappings.push([\n\t\t\t\t\t\t[startHigh + 1, endHigh + 1],\n\t\t\t\t\t\t[LOW_SURROGATE_MIN, endLow + 1]\n\t\t\t\t\t]);\n\t\t\t\t\tcomplete = true;\n\t\t\t\t} else {\n\t\t\t\t\tsurrogateMappings.push([\n\t\t\t\t\t\t[startHigh + 1, endHigh],\n\t\t\t\t\t\t[LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Step 3. `(endHigh, LOW_SURROGATE_MIN)` to `(endHigh, endLow)`.\n\t\t\tif (!complete) {\n\t\t\t\tsurrogateMappings.push([\n\t\t\t\t\t[endHigh, endHigh + 1],\n\t\t\t\t\t[LOW_SURROGATE_MIN, endLow + 1]\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\tindex += 2;\n\t\t}\n\n\t\t// The format of `surrogateMappings` is as follows:\n\t\t//\n\t\t//     [ surrogateMapping1, surrogateMapping2 ]\n\t\t//\n\t\t// i.e.:\n\t\t//\n\t\t//     [\n\t\t//       [ highSurrogates1, lowSurrogates1 ],\n\t\t//       [ highSurrogates2, lowSurrogates2 ]\n\t\t//     ]\n\t\treturn optimizeSurrogateMappings(surrogateMappings);\n\t};\n\n\tvar createSurrogateCharacterClasses = function(surrogateMappings) {\n\t\tvar result = [];\n\t\tforEach(surrogateMappings, function(surrogateMapping) {\n\t\t\tvar highSurrogates = surrogateMapping[0];\n\t\t\tvar lowSurrogates = surrogateMapping[1];\n\t\t\tresult.push(\n\t\t\t\tcreateBMPCharacterClasses(highSurrogates) +\n\t\t\t\tcreateBMPCharacterClasses(lowSurrogates)\n\t\t\t);\n\t\t});\n\t\treturn result.join('|');\n\t};\n\n\tvar createCharacterClassesFromData = function(data, bmpOnly, hasUnicodeFlag) {\n\t\tif (hasUnicodeFlag) {\n\t\t\treturn createUnicodeCharacterClasses(data);\n\t\t}\n\t\tvar result = [];\n\n\t\tvar parts = splitAtBMP(data);\n\t\tvar loneHighSurrogates = parts.loneHighSurrogates;\n\t\tvar loneLowSurrogates = parts.loneLowSurrogates;\n\t\tvar bmp = parts.bmp;\n\t\tvar astral = parts.astral;\n\t\tvar hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);\n\t\tvar hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);\n\n\t\tvar surrogateMappings = surrogateSet(astral);\n\n\t\tif (bmpOnly) {\n\t\t\tbmp = dataAddData(bmp, loneHighSurrogates);\n\t\t\thasLoneHighSurrogates = false;\n\t\t\tbmp = dataAddData(bmp, loneLowSurrogates);\n\t\t\thasLoneLowSurrogates = false;\n\t\t}\n\n\t\tif (!dataIsEmpty(bmp)) {\n\t\t\t// The data set contains BMP code points that are not high surrogates\n\t\t\t// needed for astral code points in the set.\n\t\t\tresult.push(createBMPCharacterClasses(bmp));\n\t\t}\n\t\tif (surrogateMappings.length) {\n\t\t\t// The data set contains astral code points; append character classes\n\t\t\t// based on their surrogate pairs.\n\t\t\tresult.push(createSurrogateCharacterClasses(surrogateMappings));\n\t\t}\n\t\t// https://gist.github.com/mathiasbynens/bbe7f870208abcfec860\n\t\tif (hasLoneHighSurrogates) {\n\t\t\tresult.push(\n\t\t\t\tcreateBMPCharacterClasses(loneHighSurrogates) +\n\t\t\t\t// Make sure the high surrogates aren’t part of a surrogate pair.\n\t\t\t\t'(?![\\\\uDC00-\\\\uDFFF])'\n\t\t\t);\n\t\t}\n\t\tif (hasLoneLowSurrogates) {\n\t\t\tresult.push(\n\t\t\t\t// It is not possible to accurately assert the low surrogates aren’t\n\t\t\t\t// part of a surrogate pair, since JavaScript regular expressions do\n\t\t\t\t// not support lookbehind.\n\t\t\t\t'(?:[^\\\\uD800-\\\\uDBFF]|^)' +\n\t\t\t\tcreateBMPCharacterClasses(loneLowSurrogates)\n\t\t\t);\n\t\t}\n\t\treturn result.join('|');\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// `regenerate` can be used as a constructor (and new methods can be added to\n\t// its prototype) but also as a regular function, the latter of which is the\n\t// documented and most common usage. For that reason, it’s not capitalized.\n\tvar regenerate = function(value) {\n\t\tif (arguments.length > 1) {\n\t\t\tvalue = slice.call(arguments);\n\t\t}\n\t\tif (this instanceof regenerate) {\n\t\t\tthis.data = [];\n\t\t\treturn value ? this.add(value) : this;\n\t\t}\n\t\treturn (new regenerate).add(value);\n\t};\n\n\tregenerate.version = '1.4.2';\n\n\tvar proto = regenerate.prototype;\n\textend(proto, {\n\t\t'add': function(value) {\n\t\t\tvar $this = this;\n\t\t\tif (value == null) {\n\t\t\t\treturn $this;\n\t\t\t}\n\t\t\tif (value instanceof regenerate) {\n\t\t\t\t// Allow passing other Regenerate instances.\n\t\t\t\t$this.data = dataAddData($this.data, value.data);\n\t\t\t\treturn $this;\n\t\t\t}\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tvalue = slice.call(arguments);\n\t\t\t}\n\t\t\tif (isArray(value)) {\n\t\t\t\tforEach(value, function(item) {\n\t\t\t\t\t$this.add(item);\n\t\t\t\t});\n\t\t\t\treturn $this;\n\t\t\t}\n\t\t\t$this.data = dataAdd(\n\t\t\t\t$this.data,\n\t\t\t\tisNumber(value) ? value : symbolToCodePoint(value)\n\t\t\t);\n\t\t\treturn $this;\n\t\t},\n\t\t'remove': function(value) {\n\t\t\tvar $this = this;\n\t\t\tif (value == null) {\n\t\t\t\treturn $this;\n\t\t\t}\n\t\t\tif (value instanceof regenerate) {\n\t\t\t\t// Allow passing other Regenerate instances.\n\t\t\t\t$this.data = dataRemoveData($this.data, value.data);\n\t\t\t\treturn $this;\n\t\t\t}\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tvalue = slice.call(arguments);\n\t\t\t}\n\t\t\tif (isArray(value)) {\n\t\t\t\tforEach(value, function(item) {\n\t\t\t\t\t$this.remove(item);\n\t\t\t\t});\n\t\t\t\treturn $this;\n\t\t\t}\n\t\t\t$this.data = dataRemove(\n\t\t\t\t$this.data,\n\t\t\t\tisNumber(value) ? value : symbolToCodePoint(value)\n\t\t\t);\n\t\t\treturn $this;\n\t\t},\n\t\t'addRange': function(start, end) {\n\t\t\tvar $this = this;\n\t\t\t$this.data = dataAddRange($this.data,\n\t\t\t\tisNumber(start) ? start : symbolToCodePoint(start),\n\t\t\t\tisNumber(end) ? end : symbolToCodePoint(end)\n\t\t\t);\n\t\t\treturn $this;\n\t\t},\n\t\t'removeRange': function(start, end) {\n\t\t\tvar $this = this;\n\t\t\tvar startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);\n\t\t\tvar endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);\n\t\t\t$this.data = dataRemoveRange(\n\t\t\t\t$this.data,\n\t\t\t\tstartCodePoint,\n\t\t\t\tendCodePoint\n\t\t\t);\n\t\t\treturn $this;\n\t\t},\n\t\t'intersection': function(argument) {\n\t\t\tvar $this = this;\n\t\t\t// Allow passing other Regenerate instances.\n\t\t\t// TODO: Optimize this by writing and using `dataIntersectionData()`.\n\t\t\tvar array = argument instanceof regenerate ?\n\t\t\t\tdataToArray(argument.data) :\n\t\t\t\targument;\n\t\t\t$this.data = dataIntersection($this.data, array);\n\t\t\treturn $this;\n\t\t},\n\t\t'contains': function(codePoint) {\n\t\t\treturn dataContains(\n\t\t\t\tthis.data,\n\t\t\t\tisNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint)\n\t\t\t);\n\t\t},\n\t\t'clone': function() {\n\t\t\tvar set = new regenerate;\n\t\t\tset.data = this.data.slice(0);\n\t\t\treturn set;\n\t\t},\n\t\t'toString': function(options) {\n\t\t\tvar result = createCharacterClassesFromData(\n\t\t\t\tthis.data,\n\t\t\t\toptions ? options.bmpOnly : false,\n\t\t\t\toptions ? options.hasUnicodeFlag : false\n\t\t\t);\n\t\t\tif (!result) {\n\t\t\t\t// For an empty set, return something that can be inserted `/here/` to\n\t\t\t\t// form a valid regular expression. Avoid `(?:)` since that matches the\n\t\t\t\t// empty string.\n\t\t\t\treturn '[]';\n\t\t\t}\n\t\t\t// Use `\\0` instead of `\\x00` where possible.\n\t\t\treturn result.replace(regexNull, '\\\\0$1');\n\t\t},\n\t\t'toRegExp': function(flags) {\n\t\t\tvar pattern = this.toString(\n\t\t\t\tflags && flags.indexOf('u') != -1 ?\n\t\t\t\t\t{ 'hasUnicodeFlag': true } :\n\t\t\t\t\tnull\n\t\t\t);\n\t\t\treturn RegExp(pattern, flags || '');\n\t\t},\n\t\t'valueOf': function() { // Note: `valueOf` is aliased as `toArray`.\n\t\t\treturn dataToArray(this.data);\n\t\t}\n\t});\n\n\tproto.toArray = proto.valueOf;\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn regenerate;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = regenerate;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfreeExports.regenerate = regenerate;\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.regenerate = regenerate;\n\t}\n\n}(this));\n"]},"metadata":{},"sourceType":"script"}